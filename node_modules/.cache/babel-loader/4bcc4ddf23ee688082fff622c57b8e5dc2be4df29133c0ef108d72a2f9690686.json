{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/affine-transform.ts\nvar AffineTransform = class _AffineTransform {\n  constructor() {\n    var _this = this;\n    let [m00, m01, m02, m10, m11, m12] = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 0, 0, 0];\n    __publicField(this, \"m00\");\n    __publicField(this, \"m01\");\n    __publicField(this, \"m02\");\n    __publicField(this, \"m10\");\n    __publicField(this, \"m11\");\n    __publicField(this, \"m12\");\n    __publicField(this, \"rotate\", function () {\n      return _this.prepend(_AffineTransform.rotate(...arguments));\n    });\n    __publicField(this, \"scale\", function () {\n      return _this.prepend(_AffineTransform.scale(...arguments));\n    });\n    __publicField(this, \"translate\", function () {\n      return _this.prepend(_AffineTransform.translate(...arguments));\n    });\n    this.m00 = m00;\n    this.m01 = m01;\n    this.m02 = m02;\n    this.m10 = m10;\n    this.m11 = m11;\n    this.m12 = m12;\n  }\n  applyTo(point) {\n    const {\n      x,\n      y\n    } = point;\n    const {\n      m00,\n      m01,\n      m02,\n      m10,\n      m11,\n      m12\n    } = this;\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12\n    };\n  }\n  prepend(other) {\n    return new _AffineTransform([this.m00 * other.m00 + this.m01 * other.m10,\n    // m00\n    this.m00 * other.m01 + this.m01 * other.m11,\n    // m01\n    this.m00 * other.m02 + this.m01 * other.m12 + this.m02,\n    // m02\n    this.m10 * other.m00 + this.m11 * other.m10,\n    // m10\n    this.m10 * other.m01 + this.m11 * other.m11,\n    // m11\n    this.m10 * other.m02 + this.m11 * other.m12 + this.m12\n    // m12\n    ]);\n  }\n  append(other) {\n    return new _AffineTransform([other.m00 * this.m00 + other.m01 * this.m10,\n    // m00\n    other.m00 * this.m01 + other.m01 * this.m11,\n    // m01\n    other.m00 * this.m02 + other.m01 * this.m12 + other.m02,\n    // m02\n    other.m10 * this.m00 + other.m11 * this.m10,\n    // m10\n    other.m10 * this.m01 + other.m11 * this.m11,\n    // m11\n    other.m10 * this.m02 + other.m11 * this.m12 + other.m12\n    // m12\n    ]);\n  }\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10;\n  }\n  get isInvertible() {\n    const det = this.determinant;\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;\n  }\n  invert() {\n    const det = this.determinant;\n    return new _AffineTransform([this.m11 / det,\n    // m00\n    -this.m01 / det,\n    // m01\n    (this.m01 * this.m12 - this.m11 * this.m02) / det,\n    // m02\n    -this.m10 / det,\n    // m10\n    this.m00 / det,\n    // m11\n    (this.m10 * this.m02 - this.m00 * this.m12) / det\n    // m12\n    ]);\n  }\n  get array() {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1];\n  }\n  get float32Array() {\n    return new Float32Array(this.array);\n  }\n  // Static\n  static get identity() {\n    return new _AffineTransform([1, 0, 0, 0, 1, 0]);\n  }\n  static rotate(theta, origin) {\n    const rotation = new _AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0]);\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), rotation, _AffineTransform.translate(-origin.x, -origin.y));\n    }\n    return rotation;\n  }\n  static scale(sx) {\n    let sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sx;\n    let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      x: 0,\n      y: 0\n    };\n    const scale = new _AffineTransform([sx, 0, 0, 0, sy, 0]);\n    if (origin.x !== 0 || origin.y !== 0) {\n      return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), scale, _AffineTransform.translate(-origin.x, -origin.y));\n    }\n    return scale;\n  }\n  static translate(tx, ty) {\n    return new _AffineTransform([1, 0, tx, 0, 1, ty]);\n  }\n  static multiply() {\n    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {\n      _ref[_key] = arguments[_key];\n    }\n    let [first, ...rest] = _ref;\n    if (!first) return _AffineTransform.identity;\n    return rest.reduce((result, item) => result.prepend(item), first);\n  }\n  get a() {\n    return this.m00;\n  }\n  get b() {\n    return this.m10;\n  }\n  get c() {\n    return this.m01;\n  }\n  get d() {\n    return this.m11;\n  }\n  get tx() {\n    return this.m02;\n  }\n  get ty() {\n    return this.m12;\n  }\n  get scaleComponents() {\n    return {\n      x: this.a,\n      y: this.d\n    };\n  }\n  get translationComponents() {\n    return {\n      x: this.tx,\n      y: this.ty\n    };\n  }\n  get skewComponents() {\n    return {\n      x: this.c,\n      y: this.b\n    };\n  }\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;\n  }\n};\n\n// src/align.ts\nfunction hAlign(a, ref, h) {\n  let x = ref.minX;\n  if (h === \"left-inside\") x = ref.minX;\n  if (h === \"left-outside\") x = ref.minX - ref.width;\n  if (h === \"right-inside\") x = ref.maxX - ref.width;\n  if (h === \"right-outside\") x = ref.maxX;\n  if (h === \"center\") x = ref.midX - ref.width / 2;\n  return {\n    ...a,\n    x\n  };\n}\nfunction vAlign(a, ref, v) {\n  let y = ref.minY;\n  if (v === \"top-inside\") y = ref.minY;\n  if (v === \"top-outside\") y = ref.minY - a.height;\n  if (v === \"bottom-inside\") y = ref.maxY - a.height;\n  if (v === \"bottom-outside\") y = ref.maxY;\n  if (v === \"center\") y = ref.midY - a.height / 2;\n  return {\n    ...a,\n    y\n  };\n}\nfunction alignRect(a, ref, options) {\n  const {\n    h,\n    v\n  } = options;\n  return vAlign(hAlign(a, ref, h), ref, v);\n}\n\n// src/clamp.ts\nvar clamp = (value, min3, max2) => Math.min(Math.max(value, min3), max2);\nvar clampPoint = (position, size, boundaryRect) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width);\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height);\n  return {\n    x,\n    y\n  };\n};\nvar defaultMinSize = {\n  width: 0,\n  height: 0\n};\nvar defaultMaxSize = {\n  width: Infinity,\n  height: Infinity\n};\nvar clampSize = function (size) {\n  let minSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMinSize;\n  let maxSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultMaxSize;\n  return {\n    width: Math.min(Math.max(size.width, minSize.width), maxSize.width),\n    height: Math.min(Math.max(size.height, minSize.height), maxSize.height)\n  };\n};\n\n// src/rect.ts\nvar createPoint = (x, y) => ({\n  x,\n  y\n});\nvar subtractPoints = (a, b) => createPoint(a.x - b.x, a.y - b.y);\nvar addPoints = (a, b) => createPoint(a.x + b.x, a.y + b.y);\nfunction isPoint(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\");\n}\nfunction createRect(r) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = r;\n  const midX = x + width / 2;\n  const midY = y + height / 2;\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY)\n  };\n}\nfunction isRect(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\");\n}\nfunction getRectCenters(v) {\n  const top = createPoint(v.midX, v.minY);\n  const right = createPoint(v.maxX, v.midY);\n  const bottom = createPoint(v.midX, v.maxY);\n  const left = createPoint(v.minX, v.midY);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\nfunction getRectCorners(v) {\n  const top = createPoint(v.minX, v.minY);\n  const right = createPoint(v.maxX, v.minY);\n  const bottom = createPoint(v.maxX, v.maxY);\n  const left = createPoint(v.minX, v.maxY);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\nfunction getRectEdges(v) {\n  const c = getRectCorners(v);\n  const top = [c.top, c.right];\n  const right = [c.right, c.bottom];\n  const bottom = [c.left, c.bottom];\n  const left = [c.top, c.left];\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\n\n// src/intersection.ts\nfunction intersects(a, b) {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y;\n}\nfunction intersection(a, b) {\n  const x = Math.max(a.x, b.x);\n  const y = Math.max(a.y, b.y);\n  const x2 = Math.min(a.x + a.width, b.x + b.width);\n  const y2 = Math.min(a.y + a.height, b.y + b.height);\n  return createRect({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y\n  });\n}\nfunction collisions(a, b) {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX\n  };\n}\n\n// src/distance.ts\nfunction distance(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    x: 0,\n    y: 0\n  };\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\nfunction distanceFromPoint(r, p) {\n  let x = 0;\n  let y = 0;\n  if (p.x < r.x) x = r.x - p.x;else if (p.x > r.maxX) x = p.x - r.maxX;\n  if (p.y < r.y) y = r.y - p.y;else if (p.y > r.maxY) y = p.y - r.maxY;\n  return {\n    x,\n    y,\n    value: distance({\n      x,\n      y\n    })\n  };\n}\nfunction distanceFromRect(a, b) {\n  if (intersects(a, b)) return {\n    x: 0,\n    y: 0,\n    value: 0\n  };\n  const left = a.x < b.x ? a : b;\n  const right = b.x < a.x ? a : b;\n  const upper = a.y < b.y ? a : b;\n  const lower = b.y < a.y ? a : b;\n  let x = left.x === right.x ? 0 : right.x - left.maxX;\n  x = Math.max(0, x);\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY;\n  y = Math.max(0, y);\n  return {\n    x,\n    y,\n    value: distance({\n      x,\n      y\n    })\n  };\n}\nfunction distanceBtwEdges(a, b) {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY\n  };\n}\n\n// src/closest.ts\nfunction closest() {\n  for (var _len2 = arguments.length, pts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    pts[_key2] = arguments[_key2];\n  }\n  return a => {\n    const ds = pts.map(b => distance(b, a));\n    const c = Math.min.apply(Math, ds);\n    return pts[ds.indexOf(c)];\n  };\n}\nfunction closestSideToRect(ref, r) {\n  if (r.maxX <= ref.minX) return \"left\";\n  if (r.minX >= ref.maxX) return \"right\";\n  if (r.maxY <= ref.minY) return \"top\";\n  if (r.minY >= ref.maxY) return \"bottom\";\n  return \"left\";\n}\nfunction closestSideToPoint(ref, p) {\n  const {\n    x,\n    y\n  } = p;\n  const dl = x - ref.minX;\n  const dr = ref.maxX - x;\n  const dt = y - ref.minY;\n  const db = ref.maxY - y;\n  let closest2 = dl;\n  let side = \"left\";\n  if (dr < closest2) {\n    closest2 = dr;\n    side = \"right\";\n  }\n  if (dt < closest2) {\n    closest2 = dt;\n    side = \"top\";\n  }\n  if (db < closest2) {\n    side = \"bottom\";\n  }\n  return side;\n}\n\n// src/constrain.ts\nvar constrainRect = (rect, boundary) => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height)\n  };\n};\n\n// src/contains.ts\nfunction containsPoint(r, p) {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY;\n}\nfunction containsRect(a, b) {\n  return Object.values(getRectCorners(b)).every(c => containsPoint(a, c));\n}\nfunction contains(r, v) {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v);\n}\n\n// src/equality.ts\nvar isSizeEqual = (a, b) => {\n  return a.width === b.width && a.height === b.height;\n};\nvar isPointEqual = (a, b) => {\n  return a.x === b.x && a.y === b.y;\n};\nvar isRectEqual = (a, b) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b);\n};\n\n// src/from-element.ts\nvar styleCache = /* @__PURE__ */new WeakMap();\nfunction getCacheComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window;\n    styleCache.set(el, win.getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\nfunction getElementRect(el) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return createRect(getClientRect(el, opts));\n}\nfunction getClientRect(el) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    excludeScrollbar = false,\n    excludeBorders = false\n  } = opts;\n  const {\n    x,\n    y,\n    width,\n    height\n  } = el.getBoundingClientRect();\n  const r = {\n    x,\n    y,\n    width,\n    height\n  };\n  const style = getCacheComputedStyle(el);\n  const {\n    borderLeftWidth,\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth);\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth);\n  if (excludeBorders) {\n    r.width -= borderXWidth;\n    r.height -= borderYWidth;\n    r.x += px(borderLeftWidth);\n    r.y += px(borderTopWidth);\n  }\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;\n    r.width -= scrollbarWidth;\n    r.height -= scrollbarHeight;\n  }\n  return r;\n}\nvar px = v => parseFloat(v.replace(\"px\", \"\"));\nvar sum = function () {\n  for (var _len3 = arguments.length, vals = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    vals[_key3] = arguments[_key3];\n  }\n  return vals.reduce((sum2, v) => sum2 + (v ? px(v) : 0), 0);\n};\n\n// src/from-points.ts\nfunction getRectFromPoints() {\n  for (var _len4 = arguments.length, pts = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    pts[_key4] = arguments[_key4];\n  }\n  const xs = pts.map(p => p.x);\n  const ys = pts.map(p => p.y);\n  const x = Math.min(...xs);\n  const y = Math.min(...ys);\n  const width = Math.max(...xs) - x;\n  const height = Math.max(...ys) - y;\n  return createRect({\n    x,\n    y,\n    width,\n    height\n  });\n}\n\n// src/union.ts\nvar {\n  min,\n  max\n} = Math;\nfunction union() {\n  for (var _len5 = arguments.length, rs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    rs[_key5] = arguments[_key5];\n  }\n  const pMin = {\n    x: min(...rs.map(r => r.minX)),\n    y: min(...rs.map(r => r.minY))\n  };\n  const pMax = {\n    x: max(...rs.map(r => r.maxX)),\n    y: max(...rs.map(r => r.maxY))\n  };\n  return getRectFromPoints(pMin, pMax);\n}\n\n// src/from-range.ts\nfunction fromRange(range) {\n  let rs = [];\n  const rects = Array.from(range.getClientRects());\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect));\n    return union.apply(void 0, rs);\n  }\n  let start = range.startContainer;\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode;\n  }\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start);\n    rs.push({\n      ...r,\n      x: r.maxX,\n      width: 0\n    });\n  }\n  return union.apply(void 0, rs);\n}\n\n// src/from-rotation.ts\nfunction toRad(d) {\n  return d % 360 * Math.PI / 180;\n}\nfunction rotate(a, d, c) {\n  const r = toRad(d);\n  const sin = Math.sin(r);\n  const cos = Math.cos(r);\n  const x = a.x - c.x;\n  const y = a.y - c.y;\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos\n  };\n}\nfunction getRotationRect(r, deg) {\n  const rr = Object.values(getRectCorners(r)).map(p => rotate(p, deg, r.center));\n  const xs = rr.map(p => p.x);\n  const ys = rr.map(p => p.y);\n  const minX = Math.min(...xs);\n  const minY = Math.min(...ys);\n  const maxX = Math.max(...xs);\n  const maxY = Math.max(...ys);\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  });\n}\n\n// src/from-window.ts\nfunction getWindowRect(win) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return createRect(getViewportRect(win, opts));\n}\nfunction getViewportRect(win, opts) {\n  const {\n    excludeScrollbar = false\n  } = opts;\n  const {\n    innerWidth,\n    innerHeight,\n    document: doc,\n    visualViewport\n  } = win;\n  const width = visualViewport?.width || innerWidth;\n  const height = visualViewport?.height || innerHeight;\n  const rect = {\n    x: 0,\n    y: 0,\n    width,\n    height\n  };\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;\n    rect.width -= scrollbarWidth;\n    rect.height -= scrollbarHeight;\n  }\n  return rect;\n}\n\n// src/operations.ts\nvar isSymmetric = v => \"dx\" in v || \"dy\" in v;\nfunction inset(r, i) {\n  const v = isSymmetric(i) ? {\n    left: i.dx,\n    right: i.dx,\n    top: i.dy,\n    bottom: i.dy\n  } : i;\n  const {\n    top = 0,\n    right = 0,\n    bottom = 0,\n    left = 0\n  } = v;\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom\n  });\n}\nfunction expand(r, v) {\n  const value = typeof v === \"number\" ? {\n    dx: -v,\n    dy: -v\n  } : v;\n  return inset(r, value);\n}\nfunction shrink(r, v) {\n  const value = typeof v === \"number\" ? {\n    dx: -v,\n    dy: -v\n  } : v;\n  return inset(r, value);\n}\nfunction shift(r, o) {\n  const {\n    x = 0,\n    y = 0\n  } = o;\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height\n  });\n}\n\n// src/polygon.ts\nfunction getElementPolygon(rectValue, placement) {\n  const rect = createRect(rectValue);\n  const {\n    top,\n    right,\n    left,\n    bottom\n  } = getRectCorners(rect);\n  const [base] = placement.split(\"-\");\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom]\n  }[base];\n}\nfunction isPointInPolygon(polygon, point) {\n  const {\n    x,\n    y\n  } = point;\n  let c = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n      c = !c;\n    }\n  }\n  return c;\n}\nfunction createPolygonElement() {\n  const id = \"debug-polygon\";\n  const existingPolygon = document.getElementById(id);\n  if (existingPolygon) {\n    return existingPolygon;\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\"\n  });\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n  polygon.setAttribute(\"id\", id);\n  polygon.setAttribute(\"points\", \"0,0 0,0\");\n  svg.appendChild(polygon);\n  document.body.appendChild(svg);\n  return polygon;\n}\nfunction debugPolygon(polygon) {\n  const el = createPolygonElement();\n  const points = polygon.map(point => `${point.x},${point.y}`).join(\" \");\n  el.setAttribute(\"points\", points);\n  return () => {\n    el.remove();\n  };\n}\n\n// src/compass.ts\nvar compassDirectionMap = {\n  n: {\n    x: 0.5,\n    y: 0\n  },\n  ne: {\n    x: 1,\n    y: 0\n  },\n  e: {\n    x: 1,\n    y: 0.5\n  },\n  se: {\n    x: 1,\n    y: 1\n  },\n  s: {\n    x: 0.5,\n    y: 1\n  },\n  sw: {\n    x: 0,\n    y: 1\n  },\n  w: {\n    x: 0,\n    y: 0.5\n  },\n  nw: {\n    x: 0,\n    y: 0\n  }\n};\nvar oppositeDirectionMap = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\"\n};\n\n// src/resize.ts\nvar {\n  sign,\n  abs,\n  min: min2\n} = Math;\nfunction getRectExtentPoint(rect, direction) {\n  const {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    midX,\n    midY\n  } = rect;\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX;\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY;\n  return {\n    x,\n    y\n  };\n}\nfunction getOppositeDirection(direction) {\n  return oppositeDirectionMap[direction];\n}\nfunction resizeRect(rect, offset, direction, opts) {\n  const {\n    scalingOriginMode,\n    lockAspectRatio\n  } = opts;\n  const extent = getRectExtentPoint(rect, direction);\n  const oppositeDirection = getOppositeDirection(direction);\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);\n  if (scalingOriginMode === \"center\") {\n    offset = {\n      x: offset.x * 2,\n      y: offset.y * 2\n    };\n  }\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y\n  };\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1\n  };\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y\n  };\n  const scaleX = multiplier.x * newSize.width / rect.width;\n  const scaleY = multiplier.y * newSize.height / rect.height;\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY;\n  const scale = lockAspectRatio ? {\n    x: largestMagnitude,\n    y: largestMagnitude\n  } : {\n    x: extent.x === oppositeExtent.x ? 1 : scaleX,\n    y: extent.y === oppositeExtent.y ? 1 : scaleY\n  };\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y);\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1;\n  }\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x);\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1;\n  }\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);\n    case \"center\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, {\n        x: rect.midX,\n        y: rect.midY\n      }), false);\n  }\n}\nfunction createRectFromPoints(initialPoint, finalPoint) {\n  let normalized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (normalized) {\n    return {\n      x: min2(finalPoint.x, initialPoint.x),\n      y: min2(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y)\n    };\n  }\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y\n  };\n}\nfunction transformRect(rect, transform) {\n  let normalized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const p1 = transform.applyTo({\n    x: rect.minX,\n    y: rect.minY\n  });\n  const p2 = transform.applyTo({\n    x: rect.maxX,\n    y: rect.maxY\n  });\n  return createRectFromPoints(p1, p2, normalized);\n}\nexport { AffineTransform, addPoints, alignRect, clampPoint, clampSize, closest, closestSideToPoint, closestSideToRect, collisions, constrainRect, contains, containsPoint, containsRect, createPoint, createRect, debugPolygon, distance, distanceBtwEdges, distanceFromPoint, distanceFromRect, expand, fromRange, getElementPolygon, getElementRect, getRectCenters, getRectCorners, getRectEdges, getRectFromPoints, getRotationRect, getViewportRect, getWindowRect, inset, intersection, intersects, isPoint, isPointEqual, isPointInPolygon, isRect, isRectEqual, isSizeEqual, isSymmetric, resizeRect, rotate, shift, shrink, subtractPoints, toRad, union };","map":{"version":3,"names":["AffineTransform","_AffineTransform","constructor","_this","m00","m01","m02","m10","m11","m12","arguments","length","undefined","__publicField","prepend","rotate","scale","translate","applyTo","point","x","y","other","append","determinant","isInvertible","det","isFinite","invert","array","float32Array","Float32Array","identity","theta","origin","rotation","Math","cos","sin","multiply","sx","sy","tx","ty","_len","_ref","Array","_key","first","rest","reduce","result","item","a","b","c","d","scaleComponents","translationComponents","skewComponents","toString","hAlign","ref","h","minX","width","maxX","midX","vAlign","v","minY","height","maxY","midY","alignRect","options","clamp","value","min3","max2","min","max","clampPoint","position","size","boundaryRect","defaultMinSize","defaultMaxSize","Infinity","clampSize","minSize","maxSize","createPoint","subtractPoints","addPoints","isPoint","Reflect","has","createRect","r","center","isRect","getRectCenters","top","right","bottom","left","getRectCorners","getRectEdges","intersects","intersection","x2","y2","collisions","distance","sqrt","pow","distanceFromPoint","p","distanceFromRect","upper","lower","distanceBtwEdges","closest","_len2","pts","_key2","ds","map","apply","indexOf","closestSideToRect","closestSideToPoint","dl","dr","dt","db","closest2","side","constrainRect","rect","boundary","containsPoint","containsRect","Object","values","every","contains","isSizeEqual","isPointEqual","isRectEqual","styleCache","WeakMap","getCacheComputedStyle","el","win","ownerDocument","defaultView","window","set","getComputedStyle","get","getElementRect","opts","getClientRect","excludeScrollbar","excludeBorders","getBoundingClientRect","style","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderXWidth","sum","borderYWidth","px","scrollbarWidth","offsetWidth","clientWidth","scrollbarHeight","offsetHeight","clientHeight","parseFloat","replace","_len3","vals","_key3","sum2","getRectFromPoints","_len4","_key4","xs","ys","union","_len5","rs","_key5","pMin","pMax","fromRange","range","rects","from","getClientRects","concat","start","startContainer","nodeType","Node","TEXT_NODE","parentNode","HTMLElement","push","toRad","PI","getRotationRect","deg","rr","getWindowRect","getViewportRect","innerWidth","innerHeight","document","doc","visualViewport","documentElement","isSymmetric","inset","i","dx","dy","expand","shrink","shift","o","getElementPolygon","rectValue","placement","base","split","isPointInPolygon","polygon","j","xi","yi","xj","yj","createPolygonElement","id","existingPolygon","getElementById","svg","createElementNS","assign","opacity","pointerEvents","fill","setAttribute","appendChild","body","debugPolygon","points","join","remove","compassDirectionMap","n","ne","e","se","s","sw","w","nw","oppositeDirectionMap","sign","abs","min2","getRectExtentPoint","direction","includes","getOppositeDirection","resizeRect","offset","scalingOriginMode","lockAspectRatio","extent","oppositeDirection","oppositeExtent","newExtent","multiplier","newSize","scaleX","scaleY","largestMagnitude","transformRect","createRectFromPoints","initialPoint","finalPoint","normalized","transform","p1","p2"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/affine-transform.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/align.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/clamp.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/rect.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/intersection.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/distance.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/closest.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/constrain.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/contains.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/equality.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-element.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-points.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/union.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-range.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-rotation.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-window.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/operations.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/polygon.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/compass.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/resize.ts"],"sourcesContent":["import type { Point } from \"./types\"\n\nexport class AffineTransform {\n  m00: number\n  m01: number\n  m02: number\n  m10: number\n  m11: number\n  m12: number\n\n  constructor([m00, m01, m02, m10, m11, m12]: Iterable<number> = [0, 0, 0, 0, 0, 0]) {\n    this.m00 = m00\n    this.m01 = m01\n    this.m02 = m02\n    this.m10 = m10\n    this.m11 = m11\n    this.m12 = m12\n  }\n\n  applyTo(point: Point): Point {\n    const { x, y } = point\n    const { m00, m01, m02, m10, m11, m12 } = this\n\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12,\n    }\n  }\n\n  prepend(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      this.m00 * other.m00 + this.m01 * other.m10, // m00\n      this.m00 * other.m01 + this.m01 * other.m11, // m01\n      this.m00 * other.m02 + this.m01 * other.m12 + this.m02, // m02\n      this.m10 * other.m00 + this.m11 * other.m10, // m10\n      this.m10 * other.m01 + this.m11 * other.m11, // m11\n      this.m10 * other.m02 + this.m11 * other.m12 + this.m12, // m12\n    ])\n  }\n\n  append(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      other.m00 * this.m00 + other.m01 * this.m10, // m00\n      other.m00 * this.m01 + other.m01 * this.m11, // m01\n      other.m00 * this.m02 + other.m01 * this.m12 + other.m02, // m02\n      other.m10 * this.m00 + other.m11 * this.m10, // m10\n      other.m10 * this.m01 + other.m11 * this.m11, // m11\n      other.m10 * this.m02 + other.m11 * this.m12 + other.m12, // m12\n    ])\n  }\n\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10\n  }\n\n  get isInvertible() {\n    const det = this.determinant\n\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0\n  }\n\n  invert() {\n    const det = this.determinant\n\n    return new AffineTransform([\n      this.m11 / det, // m00\n      -this.m01 / det, // m01\n      (this.m01 * this.m12 - this.m11 * this.m02) / det, // m02\n      -this.m10 / det, // m10\n      this.m00 / det, // m11\n      (this.m10 * this.m02 - this.m00 * this.m12) / det, // m12\n    ])\n  }\n\n  get array(): number[] {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1]\n  }\n\n  get float32Array(): Float32Array {\n    return new Float32Array(this.array)\n  }\n\n  // Static\n\n  static get identity(): AffineTransform {\n    return new AffineTransform([1, 0, 0, 0, 1, 0])\n  }\n\n  static rotate(theta: number, origin?: Point): AffineTransform {\n    const rotation = new AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0])\n\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        rotation,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return rotation\n  }\n\n  rotate: (typeof AffineTransform)[\"rotate\"] = (...args) => {\n    return this.prepend(AffineTransform.rotate(...args))\n  }\n\n  static scale(sx: number, sy: number = sx, origin: Point = { x: 0, y: 0 }): AffineTransform {\n    const scale = new AffineTransform([sx, 0, 0, 0, sy, 0])\n\n    if (origin.x !== 0 || origin.y !== 0) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        scale,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return scale\n  }\n\n  scale: (typeof AffineTransform)[\"scale\"] = (...args) => {\n    return this.prepend(AffineTransform.scale(...args))\n  }\n\n  static translate(tx: number, ty: number): AffineTransform {\n    return new AffineTransform([1, 0, tx, 0, 1, ty])\n  }\n\n  translate: (typeof AffineTransform)[\"translate\"] = (...args) => {\n    return this.prepend(AffineTransform.translate(...args))\n  }\n\n  static multiply(...[first, ...rest]: AffineTransform[]): AffineTransform {\n    if (!first) return AffineTransform.identity\n    return rest.reduce((result, item) => result.prepend(item), first)\n  }\n\n  get a() {\n    return this.m00\n  }\n\n  get b() {\n    return this.m10\n  }\n\n  get c() {\n    return this.m01\n  }\n\n  get d() {\n    return this.m11\n  }\n\n  get tx() {\n    return this.m02\n  }\n\n  get ty() {\n    return this.m12\n  }\n\n  get scaleComponents(): Point {\n    return { x: this.a, y: this.d }\n  }\n\n  get translationComponents(): Point {\n    return { x: this.tx, y: this.ty }\n  }\n\n  get skewComponents(): Point {\n    return { x: this.c, y: this.b }\n  }\n\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`\n  }\n}\n","import type { AlignOptions, HAlign, Rect, VAlign } from \"./types\"\n\nfunction hAlign(a: Rect, ref: Rect, h: HAlign): Rect {\n  let x = ref.minX\n  if (h === \"left-inside\") x = ref.minX\n  if (h === \"left-outside\") x = ref.minX - ref.width\n  if (h === \"right-inside\") x = ref.maxX - ref.width\n  if (h === \"right-outside\") x = ref.maxX\n  if (h === \"center\") x = ref.midX - ref.width / 2\n  return { ...a, x }\n}\n\nfunction vAlign(a: Rect, ref: Rect, v: VAlign): Rect {\n  let y = ref.minY\n  if (v === \"top-inside\") y = ref.minY\n  if (v === \"top-outside\") y = ref.minY - a.height\n  if (v === \"bottom-inside\") y = ref.maxY - a.height\n  if (v === \"bottom-outside\") y = ref.maxY\n  if (v === \"center\") y = ref.midY - a.height / 2\n  return { ...a, y }\n}\n\nexport function alignRect(a: Rect, ref: Rect, options: AlignOptions): Rect {\n  const { h, v } = options\n  return vAlign(hAlign(a, ref, h), ref, v)\n}\n","import type { Point, RectInit, Size } from \"./types\"\n\nconst clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max)\n\nexport const clampPoint = (position: Point, size: Size, boundaryRect: RectInit) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width)\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height)\n  return { x, y }\n}\n\nconst defaultMinSize: Size = {\n  width: 0,\n  height: 0,\n}\n\nconst defaultMaxSize: Size = {\n  width: Infinity,\n  height: Infinity,\n}\n\nexport const clampSize = (size: Size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {\n  return {\n    width: Math.min(Math.max(size.width, minSize!.width), maxSize!.width),\n    height: Math.min(Math.max(size.height, minSize!.height), maxSize!.height),\n  }\n}\n","import type { Point, Rect, RectEdge, RectInit } from \"./types\"\n\n/* -----------------------------------------------------------------------------\n * Point\n * -----------------------------------------------------------------------------*/\n\nexport const createPoint = (x: number, y: number) => ({ x, y })\n\nexport const subtractPoints = (a: Point, b: Point) => createPoint(a.x - b.x, a.y - b.y)\nexport const addPoints = (a: Point, b: Point) => createPoint(a.x + b.x, a.y + b.y)\n\nexport function isPoint(v: any): v is Point {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\")\n}\n\n/* -----------------------------------------------------------------------------\n * Rect\n * -----------------------------------------------------------------------------*/\n\nexport function createRect(r: RectInit): Rect {\n  const { x, y, width, height } = r\n  const midX = x + width / 2\n  const midY = y + height / 2\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY),\n  }\n}\n\nexport function isRect(v: any): v is Rect {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\")\n}\n\nexport function getRectCenters(v: Rect) {\n  const top = createPoint(v.midX, v.minY)\n  const right = createPoint(v.maxX, v.midY)\n  const bottom = createPoint(v.midX, v.maxY)\n  const left = createPoint(v.minX, v.midY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectCorners(v: Rect) {\n  const top = createPoint(v.minX, v.minY)\n  const right = createPoint(v.maxX, v.minY)\n  const bottom = createPoint(v.maxX, v.maxY)\n  const left = createPoint(v.minX, v.maxY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectEdges(v: Rect) {\n  const c = getRectCorners(v)\n  const top: RectEdge = [c.top, c.right]\n  const right: RectEdge = [c.right, c.bottom]\n  const bottom: RectEdge = [c.left, c.bottom]\n  const left: RectEdge = [c.top, c.left]\n  return { top, right, bottom, left }\n}\n","import { createRect } from \"./rect\"\nimport type { Rect, RectSide } from \"./types\"\n\n/**\n * Checks if a Rect intersects another Rect\n */\nexport function intersects(a: Rect, b: Rect): boolean {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y\n}\n\n/**\n * Returns a new Rect that represents the intersection between two Rects\n */\nexport function intersection(a: Rect, b: Rect): Rect {\n  const x = Math.max(a.x, b.x)\n  const y = Math.max(a.y, b.y)\n  const x2 = Math.min(a.x + a.width, b.x + b.width)\n  const y2 = Math.min(a.y + a.height, b.y + b.height)\n  return createRect({ x, y, width: x2 - x, height: y2 - y })\n}\n\n/**\n * Returns whether two rects collide along each edge\n */\nexport function collisions(a: Rect, b: Rect): Record<RectSide, boolean> {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX,\n  }\n}\n","import { intersects } from \"./intersection\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport interface DistanceValue extends Point {\n  value: number\n}\n\nexport function distance(a: Point, b: Point = { x: 0, y: 0 }): number {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nexport function distanceFromPoint(r: Rect, p: Point): DistanceValue {\n  let x = 0\n  let y = 0\n\n  if (p.x < r.x) x = r.x - p.x\n  else if (p.x > r.maxX) x = p.x - r.maxX\n\n  if (p.y < r.y) y = r.y - p.y\n  else if (p.y > r.maxY) y = p.y - r.maxY\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceFromRect(a: Rect, b: Rect): DistanceValue {\n  if (intersects(a, b)) return { x: 0, y: 0, value: 0 }\n  const left = a.x < b.x ? a : b\n  const right = b.x < a.x ? a : b\n  const upper = a.y < b.y ? a : b\n  const lower = b.y < a.y ? a : b\n  let x = left.x === right.x ? 0 : right.x - left.maxX\n  x = Math.max(0, x)\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY\n  y = Math.max(0, y)\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceBtwEdges(a: Rect, b: Rect): Record<RectSide, number> {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY,\n  }\n}\n","import { distance } from \"./distance\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport function closest(...pts: Point[]) {\n  return (a: Point): Point => {\n    const ds = pts.map((b) => distance(b, a))\n    const c = Math.min.apply(Math, ds)\n    return pts[ds.indexOf(c)]\n  }\n}\n\nexport function closestSideToRect(ref: Rect, r: Rect): RectSide {\n  if (r.maxX <= ref.minX) return \"left\"\n  if (r.minX >= ref.maxX) return \"right\"\n  if (r.maxY <= ref.minY) return \"top\"\n  if (r.minY >= ref.maxY) return \"bottom\"\n  return \"left\"\n}\n\nexport function closestSideToPoint(ref: Rect, p: Point): RectSide {\n  const { x, y } = p\n\n  const dl = x - ref.minX\n  const dr = ref.maxX - x\n  const dt = y - ref.minY\n  const db = ref.maxY - y\n\n  let closest = dl\n  let side: RectSide = \"left\"\n\n  if (dr < closest) {\n    closest = dr\n    side = \"right\"\n  }\n  if (dt < closest) {\n    closest = dt\n    side = \"top\"\n  }\n  if (db < closest) {\n    side = \"bottom\"\n  }\n\n  return side\n}\n","import type { RectInit } from \"./types\"\n\n// given a rect and a boundary, return a new rect that is constrained within the boundary\n// resize or reposition the rect so that it fits within the boundary\nexport const constrainRect = (rect: RectInit, boundary: RectInit): RectInit => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width))\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height))\n\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height),\n  }\n}\n","import { getRectCorners, isRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function containsPoint(r: Rect, p: Point): boolean {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY\n}\n\nexport function containsRect(a: Rect, b: Rect): boolean {\n  return Object.values(getRectCorners(b)).every((c) => containsPoint(a, c))\n}\n\nexport function contains(r: Rect, v: Rect | Point): boolean {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v)\n}\n","import type { Point, RectInit, Size } from \"./types\"\n\nexport const isSizeEqual = (a: Size, b: Size) => {\n  return a.width === b.width && a.height === b.height\n}\n\nexport const isPointEqual = (a: Point, b: Point) => {\n  return a.x === b.x && a.y === b.y\n}\n\nexport const isRectEqual = (a: RectInit, b: RectInit) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b)\n}\n","import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nconst styleCache = new WeakMap<HTMLElement, any>()\n\nfunction getCacheComputedStyle(el: HTMLElement) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window\n    styleCache.set(el, win.getComputedStyle(el))\n  }\n  return styleCache.get(el)\n}\n\nexport function getElementRect(el: HTMLElement, opts: ElementRectOptions = {}): Rect {\n  return createRect(getClientRect(el, opts))\n}\n\nexport type ElementRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n  /**\n   * Whether to exclude the element's borders from the calculation.\n   */\n  excludeBorders?: boolean\n}\n\nfunction getClientRect(el: HTMLElement, opts: ElementRectOptions = {}) {\n  const { excludeScrollbar = false, excludeBorders = false } = opts\n\n  const { x, y, width, height } = el.getBoundingClientRect()\n  const r = { x, y, width, height }\n\n  const style = getCacheComputedStyle(el)\n\n  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style\n\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth)\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth)\n\n  if (excludeBorders) {\n    r.width -= borderXWidth\n    r.height -= borderYWidth\n    r.x += px(borderLeftWidth)\n    r.y += px(borderTopWidth)\n  }\n\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth\n    r.width -= scrollbarWidth\n    r.height -= scrollbarHeight\n  }\n\n  return r\n}\n\nconst px = (v: string) => parseFloat(v.replace(\"px\", \"\"))\n\nconst sum = (...vals: string[]) => vals.reduce((sum, v) => sum + (v ? px(v) : 0), 0)\n","import { createRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function getRectFromPoints(...pts: Point[]): Rect {\n  const xs = pts.map((p) => p.x)\n  const ys = pts.map((p) => p.y)\n\n  const x = Math.min(...xs)\n  const y = Math.min(...ys)\n\n  const width = Math.max(...xs) - x\n  const height = Math.max(...ys) - y\n\n  return createRect({ x, y, width, height })\n}\n","import { getRectFromPoints } from \"./from-points\"\nimport type { Rect } from \"./types\"\n\nconst { min, max } = Math\n\nexport function union(...rs: Rect[]): Rect {\n  const pMin = {\n    x: min(...rs.map((r) => r.minX)),\n    y: min(...rs.map((r) => r.minY)),\n  }\n  const pMax = {\n    x: max(...rs.map((r) => r.maxX)),\n    y: max(...rs.map((r) => r.maxY)),\n  }\n  return getRectFromPoints(pMin, pMax)\n}\n","import { createRect } from \"./rect\"\nimport { getElementRect } from \"./from-element\"\nimport { union } from \"./union\"\nimport type { Rect } from \"./types\"\n\nexport function fromRange(range: Range): Rect {\n  let rs: Rect[] = []\n  const rects = Array.from(range.getClientRects())\n\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect))\n    return union.apply(undefined, rs)\n  }\n\n  let start: Node | ParentNode | null = range.startContainer\n\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode\n  }\n\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start)\n    rs.push({ ...r, x: r.maxX, width: 0 })\n  }\n\n  return union.apply(undefined, rs)\n}\n","import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function toRad(d: number) {\n  return ((d % 360) * Math.PI) / 180\n}\n\nexport function rotate(a: Point, d: number, c: Point): Point {\n  const r = toRad(d)\n\n  const sin = Math.sin(r)\n  const cos = Math.cos(r)\n\n  const x = a.x - c.x\n  const y = a.y - c.y\n\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos,\n  }\n}\n\nexport function getRotationRect(r: Rect, deg: number): Rect {\n  const rr = Object.values(getRectCorners(r)).map((p) => rotate(p, deg, r.center))\n\n  const xs = rr.map((p) => p.x)\n  const ys = rr.map((p) => p.y)\n\n  const minX = Math.min(...xs)\n  const minY = Math.min(...ys)\n\n  const maxX = Math.max(...xs)\n  const maxY = Math.max(...ys)\n\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  })\n}\n","import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nexport type WindowRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n}\n\n/**\n * Creates a rectange from window object\n */\nexport function getWindowRect(win: Window, opts: WindowRectOptions = {}): Rect {\n  return createRect(getViewportRect(win, opts))\n}\n\n/**\n * Get the rect of the window with the option to exclude the scrollbar\n */\nexport function getViewportRect(win: Window, opts: WindowRectOptions) {\n  const { excludeScrollbar = false } = opts\n  const { innerWidth, innerHeight, document: doc, visualViewport } = win\n  const width = visualViewport?.width || innerWidth\n  const height = visualViewport?.height || innerHeight\n  const rect = { x: 0, y: 0, width, height }\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight\n    rect.width -= scrollbarWidth\n    rect.height -= scrollbarHeight\n  }\n  return rect\n}\n","import { createRect } from \"./rect\"\nimport type { Point, Rect, RectInset, SymmetricRectInset } from \"./types\"\n\nexport const isSymmetric = (v: any): v is SymmetricRectInset => \"dx\" in v || \"dy\" in v\n\nexport function inset(r: Rect, i: RectInset | SymmetricRectInset): Rect {\n  const v = isSymmetric(i) ? { left: i.dx, right: i.dx, top: i.dy, bottom: i.dy } : i\n  const { top = 0, right = 0, bottom = 0, left = 0 } = v\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom,\n  })\n}\n\nexport function expand(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shrink(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shift(r: Rect, o: Partial<Point>): Rect {\n  const { x = 0, y = 0 } = o\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height,\n  })\n}\n","import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, RectInit } from \"./types\"\n\nexport function getElementPolygon(rectValue: RectInit, placement: string) {\n  const rect = createRect(rectValue)\n  const { top, right, left, bottom } = getRectCorners(rect)\n  const [base] = placement.split(\"-\")\n\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom],\n  }[base]\n}\n\nexport function isPointInPolygon(polygon: Point[], point: Point) {\n  const { x, y } = point\n  let c = false\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x\n    const yi = polygon[i].y\n    const xj = polygon[j].x\n    const yj = polygon[j].y\n\n    if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {\n      c = !c\n    }\n  }\n  return c\n}\n\nfunction createPolygonElement() {\n  const id = \"debug-polygon\"\n  const existingPolygon = document.getElementById(id)\n  if (existingPolygon) {\n    return existingPolygon\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\",\n  })\n\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\")\n  polygon.setAttribute(\"id\", id)\n  polygon.setAttribute(\"points\", \"0,0 0,0\")\n  svg.appendChild(polygon)\n  document.body.appendChild(svg)\n  return polygon\n}\n\nexport function debugPolygon(polygon: Point[]) {\n  const el = createPolygonElement()\n  const points = polygon.map((point) => `${point.x},${point.y}`).join(\" \")\n  el.setAttribute(\"points\", points)\n  return () => {\n    el.remove()\n  }\n}\n","import type { Point } from \"./types\"\n\nexport type CompassDirection = \"n\" | \"ne\" | \"e\" | \"se\" | \"s\" | \"sw\" | \"w\" | \"nw\"\n\nexport const compassDirectionMap: Record<CompassDirection, Point> = {\n  n: { x: 0.5, y: 0 },\n  ne: { x: 1, y: 0 },\n  e: { x: 1, y: 0.5 },\n  se: { x: 1, y: 1 },\n  s: { x: 0.5, y: 1 },\n  sw: { x: 0, y: 1 },\n  w: { x: 0, y: 0.5 },\n  nw: { x: 0, y: 0 },\n}\n\nexport const oppositeDirectionMap: Record<CompassDirection, CompassDirection> = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\",\n}\n","import { AffineTransform } from \"./affine-transform\"\nimport { compassDirectionMap, oppositeDirectionMap, type CompassDirection } from \"./compass\"\nimport type { Point, Rect, RectInit, ScalingOptions } from \"./types\"\n\nconst { sign, abs, min } = Math\n\nfunction getRectExtentPoint(rect: Rect, direction: CompassDirection) {\n  const { minX, minY, maxX, maxY, midX, midY } = rect\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY\n  return { x, y }\n}\n\nfunction getOppositeDirection(direction: CompassDirection) {\n  return oppositeDirectionMap[direction]\n}\n\nexport function resizeRect(rect: Rect, offset: Point, direction: CompassDirection, opts: ScalingOptions) {\n  const { scalingOriginMode, lockAspectRatio } = opts\n\n  const extent = getRectExtentPoint(rect, direction)\n\n  const oppositeDirection = getOppositeDirection(direction)\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection)\n\n  if (scalingOriginMode === \"center\") {\n    offset = { x: offset.x * 2, y: offset.y * 2 }\n  }\n\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y,\n  }\n\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1,\n  }\n\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y,\n  }\n\n  const scaleX = (multiplier.x * newSize.width) / rect.width\n  const scaleY = (multiplier.y * newSize.height) / rect.height\n\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY\n\n  const scale = lockAspectRatio\n    ? { x: largestMagnitude, y: largestMagnitude }\n    : {\n        x: extent.x === oppositeExtent.x ? 1 : scaleX,\n        y: extent.y === oppositeExtent.y ? 1 : scaleY,\n      }\n\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y)\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1\n  }\n\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x)\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1\n  }\n\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false)\n    case \"center\":\n      return transformRect(\n        rect,\n        AffineTransform.scale(scale.x, scale.y, {\n          x: rect.midX,\n          y: rect.midY,\n        }),\n        false,\n      )\n  }\n}\n\nfunction createRectFromPoints(initialPoint: Point, finalPoint: Point, normalized: boolean = true): RectInit {\n  if (normalized) {\n    return {\n      x: min(finalPoint.x, initialPoint.x),\n      y: min(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y),\n    }\n  }\n\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y,\n  }\n}\n\nfunction transformRect(rect: Rect, transform: AffineTransform, normalized = true): RectInit {\n  const p1 = transform.applyTo({ x: rect.minX, y: rect.minY })\n  const p2 = transform.applyTo({ x: rect.maxX, y: rect.maxY })\n  return createRectFromPoints(p1, p2, normalized)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}