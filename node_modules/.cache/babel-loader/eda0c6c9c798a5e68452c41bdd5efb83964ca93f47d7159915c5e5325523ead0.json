{"ast":null,"code":"// src/get-placement.ts\nimport { arrow, autoUpdate, computePosition, flip, limitShift, offset, shift, size } from \"@floating-ui/dom\";\nimport { getWindow, raf } from \"@zag-js/dom-query\";\nimport { compact, isNull, noop, runIfFn } from \"@zag-js/utils\";\n\n// src/get-anchor.ts\nimport { isHTMLElement } from \"@zag-js/dom-query\";\nfunction createDOMRect() {\n  let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (typeof DOMRect === \"function\") {\n    return new DOMRect(x, y, width, height);\n  }\n  const rect = {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x\n  };\n  return {\n    ...rect,\n    toJSON: () => rect\n  };\n}\nfunction getDOMRect(anchorRect) {\n  if (!anchorRect) return createDOMRect();\n  const {\n    x,\n    y,\n    width,\n    height\n  } = anchorRect;\n  return createDOMRect(x, y, width, height);\n}\nfunction getAnchorElement(anchorElement, getAnchorRect) {\n  return {\n    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,\n    getBoundingClientRect: () => {\n      const anchor = anchorElement;\n      const anchorRect = getAnchorRect?.(anchor);\n      if (anchorRect || !anchor) {\n        return getDOMRect(anchorRect);\n      }\n      return anchor.getBoundingClientRect();\n    }\n  };\n}\n\n// src/middleware.ts\nvar toVar = value => ({\n  variable: value,\n  reference: `var(${value})`\n});\nvar cssVars = {\n  arrowSize: toVar(\"--arrow-size\"),\n  arrowSizeHalf: toVar(\"--arrow-size-half\"),\n  arrowBg: toVar(\"--arrow-background\"),\n  transformOrigin: toVar(\"--transform-origin\"),\n  arrowOffset: toVar(\"--arrow-offset\")\n};\nvar getTransformOrigin = arrow2 => ({\n  top: \"bottom center\",\n  \"top-start\": arrow2 ? `${arrow2.x}px bottom` : \"left bottom\",\n  \"top-end\": arrow2 ? `${arrow2.x}px bottom` : \"right bottom\",\n  bottom: \"top center\",\n  \"bottom-start\": arrow2 ? `${arrow2.x}px top` : \"top left\",\n  \"bottom-end\": arrow2 ? `${arrow2.x}px top` : \"top right\",\n  left: \"right center\",\n  \"left-start\": arrow2 ? `right ${arrow2.y}px` : \"right top\",\n  \"left-end\": arrow2 ? `right ${arrow2.y}px` : \"right bottom\",\n  right: \"left center\",\n  \"right-start\": arrow2 ? `left ${arrow2.y}px` : \"left top\",\n  \"right-end\": arrow2 ? `left ${arrow2.y}px` : \"left bottom\"\n});\nvar transformOriginMiddleware = {\n  name: \"transformOrigin\",\n  fn(_ref) {\n    let {\n      placement,\n      elements,\n      middlewareData\n    } = _ref;\n    const {\n      arrow: arrow2\n    } = middlewareData;\n    const transformOrigin = getTransformOrigin(arrow2)[placement];\n    const {\n      floating\n    } = elements;\n    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);\n    return {\n      data: {\n        transformOrigin\n      }\n    };\n  }\n};\nvar rectMiddleware = {\n  name: \"rects\",\n  fn(_ref2) {\n    let {\n      rects\n    } = _ref2;\n    return {\n      data: rects\n    };\n  }\n};\nvar shiftArrowMiddleware = arrowEl => {\n  if (!arrowEl) return;\n  return {\n    name: \"shiftArrow\",\n    fn(_ref3) {\n      let {\n        placement,\n        middlewareData\n      } = _ref3;\n      if (!middlewareData.arrow) return {};\n      const {\n        x,\n        y\n      } = middlewareData.arrow;\n      const dir = placement.split(\"-\")[0];\n      Object.assign(arrowEl.style, {\n        left: x != null ? `${x}px` : \"\",\n        top: y != null ? `${y}px` : \"\",\n        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`\n      });\n      return {};\n    }\n  };\n};\n\n// src/placement.ts\nfunction isValidPlacement(v) {\n  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v);\n}\nfunction getPlacementDetails(placement) {\n  const [side, align] = placement.split(\"-\");\n  return {\n    side,\n    align,\n    hasAlign: align != null\n  };\n}\nfunction getPlacementSide(placement) {\n  return placement.split(\"-\")[0];\n}\n\n// src/get-placement.ts\nvar defaultOptions = {\n  strategy: \"absolute\",\n  placement: \"bottom\",\n  listeners: true,\n  gutter: 8,\n  flip: true,\n  slide: true,\n  overlap: false,\n  sameWidth: false,\n  fitViewport: false,\n  overflowPadding: 8,\n  arrowPadding: 4\n};\nfunction roundByDpr(win, value) {\n  const dpr = win.devicePixelRatio || 1;\n  return Math.round(value * dpr) / dpr;\n}\nfunction getBoundaryMiddleware(opts) {\n  return runIfFn(opts.boundary);\n}\nfunction getArrowMiddleware(arrowElement, opts) {\n  if (!arrowElement) return;\n  return arrow({\n    element: arrowElement,\n    padding: opts.arrowPadding\n  });\n}\nfunction getOffsetMiddleware(arrowElement, opts) {\n  if (isNull(opts.offset ?? opts.gutter)) return;\n  return offset(_ref4 => {\n    let {\n      placement\n    } = _ref4;\n    const arrowOffset = (arrowElement?.clientHeight || 0) / 2;\n    const gutter = opts.offset?.mainAxis ?? opts.gutter;\n    const mainAxis = typeof gutter === \"number\" ? gutter + arrowOffset : gutter ?? arrowOffset;\n    const {\n      hasAlign\n    } = getPlacementDetails(placement);\n    const shift2 = !hasAlign ? opts.shift : void 0;\n    const crossAxis = opts.offset?.crossAxis ?? shift2;\n    return compact({\n      crossAxis,\n      mainAxis,\n      alignmentAxis: opts.shift\n    });\n  });\n}\nfunction getFlipMiddleware(opts) {\n  if (!opts.flip) return;\n  return flip({\n    boundary: getBoundaryMiddleware(opts),\n    padding: opts.overflowPadding,\n    fallbackPlacements: opts.flip === true ? void 0 : opts.flip\n  });\n}\nfunction getShiftMiddleware(opts) {\n  if (!opts.slide && !opts.overlap) return;\n  return shift({\n    boundary: getBoundaryMiddleware(opts),\n    mainAxis: opts.slide,\n    crossAxis: opts.overlap,\n    padding: opts.overflowPadding,\n    limiter: limitShift()\n  });\n}\nfunction getSizeMiddleware(opts) {\n  return size({\n    padding: opts.overflowPadding,\n    apply(_ref5) {\n      let {\n        elements,\n        rects,\n        availableHeight,\n        availableWidth\n      } = _ref5;\n      const floating = elements.floating;\n      const referenceWidth = Math.round(rects.reference.width);\n      availableWidth = Math.floor(availableWidth);\n      availableHeight = Math.floor(availableHeight);\n      floating.style.setProperty(\"--reference-width\", `${referenceWidth}px`);\n      floating.style.setProperty(\"--available-width\", `${availableWidth}px`);\n      floating.style.setProperty(\"--available-height\", `${availableHeight}px`);\n    }\n  });\n}\nfunction getAutoUpdateOptions(opts) {\n  if (!opts) return {};\n  if (opts === true) {\n    return {\n      ancestorResize: true,\n      ancestorScroll: true,\n      elementResize: true,\n      layoutShift: true\n    };\n  }\n  return opts;\n}\nfunction getPlacementImpl(referenceOrVirtual, floating) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);\n  if (!floating || !reference) return;\n  const options = Object.assign({}, defaultOptions, opts);\n  const arrowEl = floating.querySelector(\"[data-part=arrow]\");\n  const middleware = [getOffsetMiddleware(arrowEl, options), getFlipMiddleware(options), getShiftMiddleware(options), getArrowMiddleware(arrowEl, options), shiftArrowMiddleware(arrowEl), transformOriginMiddleware, getSizeMiddleware(options), rectMiddleware];\n  const {\n    placement,\n    strategy,\n    onComplete,\n    onPositioned\n  } = options;\n  const updatePosition = async () => {\n    if (!reference || !floating) return;\n    const pos = await computePosition(reference, floating, {\n      placement,\n      middleware,\n      strategy\n    });\n    onComplete?.(pos);\n    onPositioned?.({\n      placed: true\n    });\n    const win = getWindow(floating);\n    const x = roundByDpr(win, pos.x);\n    const y = roundByDpr(win, pos.y);\n    floating.style.setProperty(\"--x\", `${x}px`);\n    floating.style.setProperty(\"--y\", `${y}px`);\n    const contentEl = floating.firstElementChild;\n    if (contentEl) {\n      const zIndex = win.getComputedStyle(contentEl).zIndex;\n      floating.style.setProperty(\"--z-index\", zIndex);\n    }\n  };\n  const update = async () => {\n    if (opts.updatePosition) {\n      await opts.updatePosition({\n        updatePosition\n      });\n      onPositioned?.({\n        placed: true\n      });\n    } else {\n      await updatePosition();\n    }\n  };\n  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);\n  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop;\n  update();\n  return () => {\n    cancelAutoUpdate?.();\n    onPositioned?.({\n      placed: false\n    });\n  };\n}\nfunction getPlacement(referenceOrFn, floatingOrFn) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    defer,\n    ...options\n  } = opts;\n  const func = defer ? raf : v => v();\n  const cleanups = [];\n  cleanups.push(func(() => {\n    const reference = typeof referenceOrFn === \"function\" ? referenceOrFn() : referenceOrFn;\n    const floating = typeof floatingOrFn === \"function\" ? floatingOrFn() : floatingOrFn;\n    cleanups.push(getPlacementImpl(reference, floating, options));\n  }));\n  return () => {\n    cleanups.forEach(fn => fn?.());\n  };\n}\n\n// src/get-styles.ts\nvar ARROW_FLOATING_STYLE = {\n  bottom: \"rotate(45deg)\",\n  left: \"rotate(135deg)\",\n  top: \"rotate(225deg)\",\n  right: \"rotate(315deg)\"\n};\nfunction getPlacementStyles() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    placement,\n    sameWidth,\n    fitViewport,\n    strategy = \"absolute\"\n  } = options;\n  return {\n    arrow: {\n      position: \"absolute\",\n      width: cssVars.arrowSize.reference,\n      height: cssVars.arrowSize.reference,\n      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,\n      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`\n    },\n    arrowTip: {\n      // @ts-expect-error - Fix this\n      transform: placement ? ARROW_FLOATING_STYLE[placement.split(\"-\")[0]] : void 0,\n      background: cssVars.arrowBg.reference,\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      zIndex: \"inherit\"\n    },\n    floating: {\n      position: strategy,\n      isolation: \"isolate\",\n      minWidth: sameWidth ? void 0 : \"max-content\",\n      width: sameWidth ? \"var(--reference-width)\" : void 0,\n      maxWidth: fitViewport ? \"var(--available-width)\" : void 0,\n      maxHeight: fitViewport ? \"var(--available-height)\" : void 0,\n      top: \"0px\",\n      left: \"0px\",\n      // move off-screen if placement is not defined\n      transform: placement ? \"translate3d(var(--x), var(--y), 0)\" : \"translate3d(0, -100vh, 0)\",\n      zIndex: \"var(--z-index)\"\n    }\n  };\n}\nexport { getPlacement, getPlacementSide, getPlacementStyles, isValidPlacement };","map":{"version":3,"names":["arrow","autoUpdate","computePosition","flip","limitShift","offset","shift","size","getWindow","raf","compact","isNull","noop","runIfFn","isHTMLElement","createDOMRect","x","arguments","length","undefined","y","width","height","DOMRect","rect","top","right","bottom","left","toJSON","getDOMRect","anchorRect","getAnchorElement","anchorElement","getAnchorRect","contextElement","getBoundingClientRect","anchor","toVar","value","variable","reference","cssVars","arrowSize","arrowSizeHalf","arrowBg","transformOrigin","arrowOffset","getTransformOrigin","arrow2","transformOriginMiddleware","name","fn","_ref","placement","elements","middlewareData","floating","style","setProperty","data","rectMiddleware","_ref2","rects","shiftArrowMiddleware","arrowEl","_ref3","dir","split","Object","assign","isValidPlacement","v","test","getPlacementDetails","side","align","hasAlign","getPlacementSide","defaultOptions","strategy","listeners","gutter","slide","overlap","sameWidth","fitViewport","overflowPadding","arrowPadding","roundByDpr","win","dpr","devicePixelRatio","Math","round","getBoundaryMiddleware","opts","boundary","getArrowMiddleware","arrowElement","element","padding","getOffsetMiddleware","_ref4","clientHeight","mainAxis","shift2","crossAxis","alignmentAxis","getFlipMiddleware","fallbackPlacements","getShiftMiddleware","limiter","getSizeMiddleware","apply","_ref5","availableHeight","availableWidth","referenceWidth","floor","getAutoUpdateOptions","ancestorResize","ancestorScroll","elementResize","layoutShift","getPlacementImpl","referenceOrVirtual","options","querySelector","middleware","onComplete","onPositioned","updatePosition","pos","placed","contentEl","firstElementChild","zIndex","getComputedStyle","update","autoUpdateOptions","cancelAutoUpdate","getPlacement","referenceOrFn","floatingOrFn","defer","func","cleanups","push","forEach","ARROW_FLOATING_STYLE","getPlacementStyles","position","arrowTip","transform","background","isolation","minWidth","maxWidth","maxHeight"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/popper/src/get-placement.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/popper/src/get-anchor.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/popper/src/middleware.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/popper/src/placement.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/popper/src/get-styles.ts"],"sourcesContent":["import type { AutoUpdateOptions, Middleware } from \"@floating-ui/dom\"\nimport { arrow, autoUpdate, computePosition, flip, limitShift, offset, shift, size } from \"@floating-ui/dom\"\nimport { getWindow, raf } from \"@zag-js/dom-query\"\nimport { compact, isNull, noop, runIfFn } from \"@zag-js/utils\"\nimport { getAnchorElement } from \"./get-anchor\"\nimport { rectMiddleware, shiftArrowMiddleware, transformOriginMiddleware } from \"./middleware\"\nimport { getPlacementDetails } from \"./placement\"\nimport type { MaybeElement, MaybeFn, MaybeRectElement, PositioningOptions } from \"./types\"\n\nconst defaultOptions: PositioningOptions = {\n  strategy: \"absolute\",\n  placement: \"bottom\",\n  listeners: true,\n  gutter: 8,\n  flip: true,\n  slide: true,\n  overlap: false,\n  sameWidth: false,\n  fitViewport: false,\n  overflowPadding: 8,\n  arrowPadding: 4,\n}\n\nfunction roundByDpr(win: Window, value: number) {\n  const dpr = win.devicePixelRatio || 1\n  return Math.round(value * dpr) / dpr\n}\n\nfunction getBoundaryMiddleware(opts: PositioningOptions) {\n  return runIfFn(opts.boundary)\n}\n\nfunction getArrowMiddleware(arrowElement: HTMLElement | null, opts: PositioningOptions) {\n  if (!arrowElement) return\n  return arrow({\n    element: arrowElement,\n    padding: opts.arrowPadding,\n  })\n}\n\nfunction getOffsetMiddleware(arrowElement: HTMLElement | null, opts: PositioningOptions) {\n  if (isNull(opts.offset ?? opts.gutter)) return\n  return offset(({ placement }) => {\n    const arrowOffset = (arrowElement?.clientHeight || 0) / 2\n\n    const gutter = opts.offset?.mainAxis ?? opts.gutter\n    const mainAxis = typeof gutter === \"number\" ? gutter + arrowOffset : gutter ?? arrowOffset\n\n    const { hasAlign } = getPlacementDetails(placement)\n    const shift = !hasAlign ? opts.shift : undefined\n    const crossAxis = opts.offset?.crossAxis ?? shift\n\n    return compact({\n      crossAxis: crossAxis,\n      mainAxis: mainAxis,\n      alignmentAxis: opts.shift,\n    })\n  })\n}\n\nfunction getFlipMiddleware(opts: PositioningOptions) {\n  if (!opts.flip) return\n  return flip({\n    boundary: getBoundaryMiddleware(opts),\n    padding: opts.overflowPadding,\n    fallbackPlacements: opts.flip === true ? undefined : opts.flip,\n  })\n}\n\nfunction getShiftMiddleware(opts: PositioningOptions) {\n  if (!opts.slide && !opts.overlap) return\n  return shift({\n    boundary: getBoundaryMiddleware(opts),\n    mainAxis: opts.slide,\n    crossAxis: opts.overlap,\n    padding: opts.overflowPadding,\n    limiter: limitShift(),\n  })\n}\n\nfunction getSizeMiddleware(opts: PositioningOptions) {\n  return size({\n    padding: opts.overflowPadding,\n    apply({ elements, rects, availableHeight, availableWidth }) {\n      const floating = elements.floating\n\n      const referenceWidth = Math.round(rects.reference.width)\n      availableWidth = Math.floor(availableWidth)\n      availableHeight = Math.floor(availableHeight)\n\n      floating.style.setProperty(\"--reference-width\", `${referenceWidth}px`)\n      floating.style.setProperty(\"--available-width\", `${availableWidth}px`)\n      floating.style.setProperty(\"--available-height\", `${availableHeight}px`)\n    },\n  })\n}\n\nfunction getAutoUpdateOptions(opts?: boolean | AutoUpdateOptions): AutoUpdateOptions {\n  if (!opts) return {}\n  if (opts === true) {\n    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true }\n  }\n  return opts\n}\n\nfunction getPlacementImpl(referenceOrVirtual: MaybeRectElement, floating: MaybeElement, opts: PositioningOptions = {}) {\n  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect)\n  if (!floating || !reference) return\n  const options = Object.assign({}, defaultOptions, opts)\n\n  /* -----------------------------------------------------------------------------\n   * The middleware stack\n   * -----------------------------------------------------------------------------*/\n\n  const arrowEl = floating.querySelector<HTMLElement>(\"[data-part=arrow]\")\n\n  const middleware: (Middleware | undefined)[] = [\n    getOffsetMiddleware(arrowEl, options),\n    getFlipMiddleware(options),\n    getShiftMiddleware(options),\n    getArrowMiddleware(arrowEl, options),\n    shiftArrowMiddleware(arrowEl),\n    transformOriginMiddleware,\n    getSizeMiddleware(options),\n    rectMiddleware,\n  ]\n\n  /* -----------------------------------------------------------------------------\n   * The actual positioning function\n   * -----------------------------------------------------------------------------*/\n\n  const { placement, strategy, onComplete, onPositioned } = options\n\n  const updatePosition = async () => {\n    if (!reference || !floating) return\n\n    const pos = await computePosition(reference, floating, {\n      placement,\n      middleware,\n      strategy,\n    })\n\n    onComplete?.(pos)\n    onPositioned?.({ placed: true })\n\n    const win = getWindow(floating)\n    const x = roundByDpr(win, pos.x)\n    const y = roundByDpr(win, pos.y)\n\n    floating.style.setProperty(\"--x\", `${x}px`)\n    floating.style.setProperty(\"--y\", `${y}px`)\n\n    const contentEl = floating.firstElementChild\n\n    if (contentEl) {\n      const zIndex = win.getComputedStyle(contentEl).zIndex\n      floating.style.setProperty(\"--z-index\", zIndex)\n    }\n  }\n\n  const update = async () => {\n    if (opts.updatePosition) {\n      await opts.updatePosition({ updatePosition })\n      onPositioned?.({ placed: true })\n    } else {\n      await updatePosition()\n    }\n  }\n\n  const autoUpdateOptions = getAutoUpdateOptions(options.listeners)\n  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop\n\n  update()\n\n  return () => {\n    cancelAutoUpdate?.()\n    onPositioned?.({ placed: false })\n  }\n}\n\nexport function getPlacement(\n  referenceOrFn: MaybeFn<MaybeRectElement>,\n  floatingOrFn: MaybeFn<MaybeElement>,\n  opts: PositioningOptions & { defer?: boolean } = {},\n) {\n  const { defer, ...options } = opts\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const reference = typeof referenceOrFn === \"function\" ? referenceOrFn() : referenceOrFn\n      const floating = typeof floatingOrFn === \"function\" ? floatingOrFn() : floatingOrFn\n      cleanups.push(getPlacementImpl(reference, floating, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","import { isHTMLElement } from \"@zag-js/dom-query\"\nimport type { AnchorRect, MaybeRectElement } from \"./types\"\n\nexport function createDOMRect(x = 0, y = 0, width = 0, height = 0) {\n  if (typeof DOMRect === \"function\") {\n    return new DOMRect(x, y, width, height)\n  }\n  const rect = {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n  }\n  return { ...rect, toJSON: () => rect }\n}\n\nfunction getDOMRect(anchorRect?: AnchorRect | null) {\n  if (!anchorRect) return createDOMRect()\n  const { x, y, width, height } = anchorRect\n  return createDOMRect(x, y, width, height)\n}\n\nexport function getAnchorElement(\n  anchorElement: MaybeRectElement,\n  getAnchorRect?: (anchor: MaybeRectElement) => AnchorRect | null,\n) {\n  return {\n    contextElement: isHTMLElement(anchorElement) ? anchorElement : undefined,\n    getBoundingClientRect: () => {\n      const anchor = anchorElement\n      const anchorRect = getAnchorRect?.(anchor)\n      if (anchorRect || !anchor) {\n        return getDOMRect(anchorRect)\n      }\n      return anchor.getBoundingClientRect()\n    },\n  }\n}\n","import type { Coords, Middleware } from \"@floating-ui/dom\"\nimport type { PlacementSide } from \"./types\"\n\n/* -----------------------------------------------------------------------------\n * Shared middleware utils\n * -----------------------------------------------------------------------------*/\n\nconst toVar = (value: string) => ({ variable: value, reference: `var(${value})` })\n\nexport const cssVars = {\n  arrowSize: toVar(\"--arrow-size\"),\n  arrowSizeHalf: toVar(\"--arrow-size-half\"),\n  arrowBg: toVar(\"--arrow-background\"),\n  transformOrigin: toVar(\"--transform-origin\"),\n  arrowOffset: toVar(\"--arrow-offset\"),\n}\n\n/* -----------------------------------------------------------------------------\n * Transform Origin Middleware\n * -----------------------------------------------------------------------------*/\n\nconst getTransformOrigin = (arrow?: Partial<Coords>) => ({\n  top: \"bottom center\",\n  \"top-start\": arrow ? `${arrow.x}px bottom` : \"left bottom\",\n  \"top-end\": arrow ? `${arrow.x}px bottom` : \"right bottom\",\n  bottom: \"top center\",\n  \"bottom-start\": arrow ? `${arrow.x}px top` : \"top left\",\n  \"bottom-end\": arrow ? `${arrow.x}px top` : \"top right\",\n  left: \"right center\",\n  \"left-start\": arrow ? `right ${arrow.y}px` : \"right top\",\n  \"left-end\": arrow ? `right ${arrow.y}px` : \"right bottom\",\n  right: \"left center\",\n  \"right-start\": arrow ? `left ${arrow.y}px` : \"left top\",\n  \"right-end\": arrow ? `left ${arrow.y}px` : \"left bottom\",\n})\n\nexport const transformOriginMiddleware: Middleware = {\n  name: \"transformOrigin\",\n  fn({ placement, elements, middlewareData }) {\n    const { arrow } = middlewareData\n    const transformOrigin = getTransformOrigin(arrow)[placement]\n\n    const { floating } = elements\n    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin)\n\n    return {\n      data: { transformOrigin },\n    }\n  },\n}\n\n/* -----------------------------------------------------------------------------\n * Rect Middleware (to expose the rect data)\n * -----------------------------------------------------------------------------*/\n\nexport const rectMiddleware: Middleware = {\n  name: \"rects\",\n  fn({ rects }) {\n    return {\n      data: rects,\n    }\n  },\n}\n\n/* -----------------------------------------------------------------------------\n * Arrow Middleware\n * -----------------------------------------------------------------------------*/\n\nexport const shiftArrowMiddleware = (arrowEl: HTMLElement | null): Middleware | undefined => {\n  if (!arrowEl) return\n  return {\n    name: \"shiftArrow\",\n    fn({ placement, middlewareData }) {\n      if (!middlewareData.arrow) return {}\n      const { x, y } = middlewareData.arrow\n      const dir = placement.split(\"-\")[0] as PlacementSide\n\n      Object.assign(arrowEl.style, {\n        left: x != null ? `${x}px` : \"\",\n        top: y != null ? `${y}px` : \"\",\n        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`,\n      })\n\n      return {}\n    },\n  }\n}\n","import type { Placement } from \"@floating-ui/dom\"\nimport type { PlacementAlign, PlacementSide } from \"./types\"\n\nexport function isValidPlacement(v: string): v is Placement {\n  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v)\n}\n\nexport function getPlacementDetails(placement: Placement) {\n  const [side, align] = placement.split(\"-\") as [PlacementSide, PlacementAlign | undefined]\n  return { side, align, hasAlign: align != null }\n}\n\nexport function getPlacementSide(placement: Placement): PlacementSide {\n  return placement.split(\"-\")[0] as PlacementSide\n}\n","import type { Placement } from \"@floating-ui/dom\"\nimport { cssVars } from \"./middleware\"\nimport type { PositioningOptions } from \"./types\"\n\nexport interface GetPlacementStylesOptions {\n  placement?: Placement\n}\n\nconst ARROW_FLOATING_STYLE = {\n  bottom: \"rotate(45deg)\",\n  left: \"rotate(135deg)\",\n  top: \"rotate(225deg)\",\n  right: \"rotate(315deg)\",\n} as const\n\nexport function getPlacementStyles(\n  options: Pick<PositioningOptions, \"placement\" | \"sameWidth\" | \"fitViewport\" | \"strategy\"> = {},\n) {\n  const { placement, sameWidth, fitViewport, strategy = \"absolute\" } = options\n\n  return {\n    arrow: {\n      position: \"absolute\",\n      width: cssVars.arrowSize.reference,\n      height: cssVars.arrowSize.reference,\n      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,\n      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`,\n    } as const,\n\n    arrowTip: {\n      // @ts-expect-error - Fix this\n      transform: placement ? ARROW_FLOATING_STYLE[placement.split(\"-\")[0]] : undefined,\n      background: cssVars.arrowBg.reference,\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      zIndex: \"inherit\",\n    } as const,\n\n    floating: {\n      position: strategy,\n      isolation: \"isolate\",\n      minWidth: sameWidth ? undefined : \"max-content\",\n      width: sameWidth ? \"var(--reference-width)\" : undefined,\n      maxWidth: fitViewport ? \"var(--available-width)\" : undefined,\n      maxHeight: fitViewport ? \"var(--available-height)\" : undefined,\n      top: \"0px\",\n      left: \"0px\",\n      // move off-screen if placement is not defined\n      transform: placement ? \"translate3d(var(--x), var(--y), 0)\" : \"translate3d(0, -100vh, 0)\",\n      zIndex: \"var(--z-index)\",\n    } as const,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}