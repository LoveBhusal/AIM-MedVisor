{"ast":null,"code":"// src/global.ts\nfunction getGlobal() {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n}\nfunction makeGlobal(key, value) {\n  const g = getGlobal();\n  if (!g) return value();\n  g[key] || (g[key] = value());\n  return g[key];\n}\n\n// src/proxy.ts\nimport { getUntracked, markToTrack } from \"proxy-compare\";\nvar isDev = () => process.env.NODE_ENV !== \"production\";\nvar isObject = x => typeof x === \"object\" && x !== null;\nvar proxyStateMap = makeGlobal(\"__zag__proxyStateMap\", () => /* @__PURE__ */new WeakMap());\nvar refSet = makeGlobal(\"__zag__refSet\", () => /* @__PURE__ */new WeakSet());\nvar buildProxyFunction = function () {\n  let objectIs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.is;\n  let newProxy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (target, handler) => new Proxy(target, handler);\n  let canProxy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : x => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);\n  let defaultHandlePromise = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : promise => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value;\n      case \"rejected\":\n        throw promise.reason;\n      default:\n        throw promise;\n    }\n  };\n  let snapCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : /* @__PURE__ */new WeakMap();\n  let createSnapshot = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (target, version) {\n    let handlePromise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultHandlePromise;\n    const cache = snapCache.get(target);\n    if (cache?.[0] === version) {\n      return cache[1];\n    }\n    const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n    markToTrack(snap, true);\n    snapCache.set(target, [version, snap]);\n    Reflect.ownKeys(target).forEach(key => {\n      const value = Reflect.get(target, key);\n      if (refSet.has(value)) {\n        markToTrack(value, false);\n        snap[key] = value;\n      } else if (value instanceof Promise) {\n        Object.defineProperty(snap, key, {\n          get() {\n            return handlePromise(value);\n          }\n        });\n      } else if (proxyStateMap.has(value)) {\n        snap[key] = snapshot(value, handlePromise);\n      } else {\n        snap[key] = value;\n      }\n    });\n    return Object.freeze(snap);\n  };\n  let proxyCache = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : /* @__PURE__ */new WeakMap();\n  let versionHolder = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [1, 1];\n  let proxyFunction2 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : initialObject => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\");\n    }\n    const found = proxyCache.get(initialObject);\n    if (found) {\n      return found;\n    }\n    let version = versionHolder[0];\n    const listeners = /* @__PURE__ */new Set();\n    const notifyUpdate = function (op) {\n      let nextVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ++versionHolder[0];\n      if (version !== nextVersion) {\n        version = nextVersion;\n        listeners.forEach(listener => listener(op, nextVersion));\n      }\n    };\n    let checkVersion = versionHolder[1];\n    const ensureVersion = function () {\n      let nextCheckVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ++versionHolder[1];\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion;\n        propProxyStates.forEach(_ref => {\n          let [propProxyState] = _ref;\n          const propVersion = propProxyState[1](nextCheckVersion);\n          if (propVersion > version) {\n            version = propVersion;\n          }\n        });\n      }\n      return version;\n    };\n    const createPropListener = prop => (op, nextVersion) => {\n      const newOp = [...op];\n      newOp[1] = [prop, ...newOp[1]];\n      notifyUpdate(newOp, nextVersion);\n    };\n    const propProxyStates = /* @__PURE__ */new Map();\n    const addPropListener = (prop, propProxyState) => {\n      if (isDev() && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\");\n      }\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      } else {\n        propProxyStates.set(prop, [propProxyState]);\n      }\n    };\n    const removePropListener = prop => {\n      const entry = propProxyStates.get(prop);\n      if (entry) {\n        propProxyStates.delete(prop);\n        entry[1]?.();\n      }\n    };\n    const addListener = listener => {\n      listeners.add(listener);\n      if (listeners.size === 1) {\n        propProxyStates.forEach((_ref2, prop) => {\n          let [propProxyState, prevRemove] = _ref2;\n          if (isDev() && prevRemove) {\n            throw new Error(\"remove already exists\");\n          }\n          const remove = propProxyState[3](createPropListener(prop));\n          propProxyStates.set(prop, [propProxyState, remove]);\n        });\n      }\n      const removeListener = () => {\n        listeners.delete(listener);\n        if (listeners.size === 0) {\n          propProxyStates.forEach((_ref3, prop) => {\n            let [propProxyState, remove] = _ref3;\n            if (remove) {\n              remove();\n              propProxyStates.set(prop, [propProxyState]);\n            }\n          });\n        }\n      };\n      return removeListener;\n    };\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n    const handler = {\n      deleteProperty(target, prop) {\n        const prevValue = Reflect.get(target, prop);\n        removePropListener(prop);\n        const deleted = Reflect.deleteProperty(target, prop);\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue]);\n        }\n        return deleted;\n      },\n      set(target, prop, value, receiver) {\n        const hasPrevValue = Reflect.has(target, prop);\n        const prevValue = Reflect.get(target, prop, receiver);\n        if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n          return true;\n        }\n        removePropListener(prop);\n        if (isObject(value)) {\n          value = getUntracked(value) || value;\n        }\n        let nextValue = value;\n        if (Object.getOwnPropertyDescriptor(target, prop)?.set) {} else if (value instanceof Promise) {\n          value.then(v => {\n            Object.assign(value, {\n              status: \"fulfilled\",\n              value: v\n            });\n            notifyUpdate([\"resolve\", [prop], v]);\n          }).catch(e => {\n            Object.assign(value, {\n              status: \"rejected\",\n              reason: e\n            });\n            notifyUpdate([\"reject\", [prop], e]);\n          });\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxy(value);\n          }\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n          if (childProxyState) {\n            addPropListener(prop, childProxyState);\n          }\n        }\n        Reflect.set(target, prop, nextValue, receiver);\n        notifyUpdate([\"set\", [prop], value, prevValue]);\n        return true;\n      }\n    };\n    const proxyObject = newProxy(baseObject, handler);\n    proxyCache.set(initialObject, proxyObject);\n    const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];\n    proxyStateMap.set(proxyObject, proxyState);\n    Reflect.ownKeys(initialObject).forEach(key => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n      if (desc.get || desc.set) {\n        Object.defineProperty(baseObject, key, desc);\n      } else {\n        proxyObject[key] = initialObject[key];\n      }\n    });\n    return proxyObject;\n  };\n  return [\n  // public functions\n  proxyFunction2,\n  // shared state\n  proxyStateMap, refSet,\n  // internal things\n  objectIs, newProxy, canProxy, defaultHandlePromise, snapCache, createSnapshot, proxyCache, versionHolder];\n};\nvar [proxyFunction] = buildProxyFunction();\nfunction proxy() {\n  let initialObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return proxyFunction(initialObject);\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = op => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\n\n// src/proxy-computed.ts\nfunction proxyWithComputed(initialObject, computedFns) {\n  const keys = Object.keys(computedFns);\n  keys.forEach(key => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\");\n    }\n    const computedFn = computedFns[key];\n    const {\n      get,\n      set\n    } = typeof computedFn === \"function\" ? {\n      get: computedFn\n    } : computedFn;\n    const desc = {};\n    desc.get = () => get(snapshot(proxyObject));\n    if (set) {\n      desc.set = newValue => set(proxyObject, newValue);\n    }\n    Object.defineProperty(initialObject, key, desc);\n  });\n  const proxyObject = proxy(initialObject);\n  return proxyObject;\n}\nexport { makeGlobal, proxy, proxyWithComputed, ref, snapshot, subscribe };","map":{"version":3,"names":["getGlobal","globalThis","self","window","global","makeGlobal","key","value","g","getUntracked","markToTrack","isDev","process","env","NODE_ENV","isObject","x","proxyStateMap","WeakMap","refSet","WeakSet","buildProxyFunction","objectIs","arguments","length","undefined","Object","is","newProxy","target","handler","Proxy","canProxy","has","Array","isArray","Symbol","iterator","Error","Number","Date","String","RegExp","ArrayBuffer","defaultHandlePromise","promise","status","reason","snapCache","createSnapshot","version","handlePromise","cache","get","snap","create","getPrototypeOf","set","Reflect","ownKeys","forEach","Promise","defineProperty","snapshot","freeze","proxyCache","versionHolder","proxyFunction2","initialObject","found","listeners","Set","notifyUpdate","op","nextVersion","listener","checkVersion","ensureVersion","nextCheckVersion","size","propProxyStates","_ref","propProxyState","propVersion","createPropListener","prop","newOp","Map","addPropListener","remove","removePropListener","entry","delete","addListener","add","_ref2","prevRemove","removeListener","_ref3","baseObject","deleteProperty","prevValue","deleted","receiver","hasPrevValue","nextValue","getOwnPropertyDescriptor","then","v","assign","catch","e","proxy","childProxyState","proxyObject","proxyState","desc","proxyFunction","subscribe","callback","notifyInSync","console","warn","ops","isListenerActive","push","splice","resolve","ref","obj","proxyWithComputed","computedFns","keys","computedFn","newValue"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/store/src/global.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/store/src/proxy.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/store/src/proxy-computed.ts"],"sourcesContent":["function getGlobal(): any {\n  if (typeof globalThis !== \"undefined\") return globalThis\n  if (typeof self !== \"undefined\") return self\n  if (typeof window !== \"undefined\") return window\n  if (typeof global !== \"undefined\") return global\n}\n\nexport function makeGlobal<T>(key: string, value: () => T): T {\n  const g = getGlobal()\n  if (!g) return value()\n  g[key] ||= value()\n  return g[key]\n}\n","// Credits: https://github.com/pmndrs/valtio\n\nimport { getUntracked, markToTrack } from \"proxy-compare\"\nimport { makeGlobal } from \"./global\"\n\nconst isDev = () => process.env.NODE_ENV !== \"production\"\nconst isObject = (x: unknown): x is object => typeof x === \"object\" && x !== null\n\ntype AsRef = { $$valtioRef: true }\n\ntype ProxyObject = object\n\ntype Path = (string | symbol)[]\n\ntype Op =\n  | [op: \"set\", path: Path, value: unknown, prevValue: unknown]\n  | [op: \"delete\", path: Path, prevValue: unknown]\n  | [op: \"resolve\", path: Path, value: unknown]\n  | [op: \"reject\", path: Path, error: unknown]\n\ntype Listener = (op: Op, nextVersion: number) => void\n\ntype AnyFunction = (...args: any[]) => any\n\nexport type Snapshot<T> = T extends AnyFunction\n  ? T\n  : T extends AsRef\n    ? T\n    : T extends Promise<any>\n      ? Awaited<T>\n      : {\n          readonly [K in keyof T]: Snapshot<T[K]>\n        }\n\ntype HandlePromise = <P extends Promise<any>>(promise: P) => Awaited<P>\n\ntype CreateSnapshot = <T extends object>(target: T, version: number, handlePromise?: HandlePromise) => T\n\ntype RemoveListener = () => void\ntype AddListener = (listener: Listener) => RemoveListener\n\ntype ProxyState = readonly [\n  target: object,\n  ensureVersion: (nextCheckVersion?: number) => number,\n  createSnapshot: CreateSnapshot,\n  addListener: AddListener,\n]\n\n// shared state\nconst proxyStateMap = makeGlobal(\"__zag__proxyStateMap\", () => new WeakMap<ProxyObject, ProxyState>())\nconst refSet = makeGlobal(\"__zag__refSet\", () => new WeakSet())\n\nconst buildProxyFunction = (\n  objectIs = Object.is,\n\n  newProxy = <T extends object>(target: T, handler: ProxyHandler<T>): T => new Proxy(target, handler),\n\n  canProxy = (x: unknown) =>\n    isObject(x) &&\n    !refSet.has(x) &&\n    (Array.isArray(x) || !(Symbol.iterator in x)) &&\n    !(x instanceof WeakMap) &&\n    !(x instanceof WeakSet) &&\n    !(x instanceof Error) &&\n    !(x instanceof Number) &&\n    !(x instanceof Date) &&\n    !(x instanceof String) &&\n    !(x instanceof RegExp) &&\n    !(x instanceof ArrayBuffer),\n\n  defaultHandlePromise = <P extends Promise<any>>(\n    promise: P & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\"\n      value?: Awaited<P>\n      reason?: unknown\n    },\n  ) => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value as Awaited<P>\n      case \"rejected\":\n        throw promise.reason\n      default:\n        throw promise\n    }\n  },\n\n  snapCache = new WeakMap<object, [version: number, snap: unknown]>(),\n\n  createSnapshot: CreateSnapshot = <T extends object>(\n    target: T,\n    version: number,\n    handlePromise: HandlePromise = defaultHandlePromise,\n  ): T => {\n    const cache = snapCache.get(target)\n    if (cache?.[0] === version) {\n      return cache[1] as T\n    }\n    const snap: any = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target))\n    markToTrack(snap, true) // mark to track\n    snapCache.set(target, [version, snap])\n    Reflect.ownKeys(target).forEach((key) => {\n      const value = Reflect.get(target, key)\n      if (refSet.has(value as object)) {\n        markToTrack(value as object, false) // mark not to track\n        snap[key] = value\n      } else if (value instanceof Promise) {\n        Object.defineProperty(snap, key, {\n          get() {\n            return handlePromise(value)\n          },\n        })\n      } else if (proxyStateMap.has(value as object)) {\n        snap[key] = snapshot(value as object, handlePromise)\n      } else {\n        snap[key] = value\n      }\n    })\n    return Object.freeze(snap)\n  },\n\n  proxyCache = new WeakMap<object, ProxyObject>(),\n\n  versionHolder = [1, 1] as [number, number],\n\n  proxyFunction = <T extends object>(initialObject: T): T => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\")\n    }\n    const found = proxyCache.get(initialObject) as T | undefined\n    if (found) {\n      return found\n    }\n    let version = versionHolder[0]\n    const listeners = new Set<Listener>()\n    const notifyUpdate = (op: Op, nextVersion = ++versionHolder[0]) => {\n      if (version !== nextVersion) {\n        version = nextVersion\n        listeners.forEach((listener) => listener(op, nextVersion))\n      }\n    }\n    let checkVersion = versionHolder[1]\n    const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion\n        propProxyStates.forEach(([propProxyState]) => {\n          const propVersion = propProxyState[1](nextCheckVersion)\n          if (propVersion > version) {\n            version = propVersion\n          }\n        })\n      }\n      return version\n    }\n    const createPropListener =\n      (prop: string | symbol): Listener =>\n      (op, nextVersion) => {\n        const newOp: Op = [...op]\n        newOp[1] = [prop, ...(newOp[1] as Path)]\n        notifyUpdate(newOp, nextVersion)\n      }\n    const propProxyStates = new Map<string | symbol, readonly [ProxyState, RemoveListener?]>()\n    const addPropListener = (prop: string | symbol, propProxyState: ProxyState) => {\n      if (isDev() && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\")\n      }\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop))\n        propProxyStates.set(prop, [propProxyState, remove])\n      } else {\n        propProxyStates.set(prop, [propProxyState])\n      }\n    }\n    const removePropListener = (prop: string | symbol) => {\n      const entry = propProxyStates.get(prop)\n      if (entry) {\n        propProxyStates.delete(prop)\n        entry[1]?.()\n      }\n    }\n    const addListener = (listener: Listener) => {\n      listeners.add(listener)\n      if (listeners.size === 1) {\n        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n          if (isDev() && prevRemove) {\n            throw new Error(\"remove already exists\")\n          }\n          const remove = propProxyState[3](createPropListener(prop))\n          propProxyStates.set(prop, [propProxyState, remove])\n        })\n      }\n      const removeListener = () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          propProxyStates.forEach(([propProxyState, remove], prop) => {\n            if (remove) {\n              remove()\n              propProxyStates.set(prop, [propProxyState])\n            }\n          })\n        }\n      }\n      return removeListener\n    }\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject))\n    const handler: ProxyHandler<T> = {\n      deleteProperty(target: T, prop: string | symbol) {\n        const prevValue = Reflect.get(target, prop)\n        removePropListener(prop)\n        const deleted = Reflect.deleteProperty(target, prop)\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue])\n        }\n        return deleted\n      },\n      set(target: T, prop: string | symbol, value: any, receiver: object) {\n        const hasPrevValue = Reflect.has(target, prop)\n        const prevValue = Reflect.get(target, prop, receiver)\n        if (\n          hasPrevValue &&\n          (objectIs(prevValue, value) || (proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value))))\n        ) {\n          return true\n        }\n        removePropListener(prop)\n        if (isObject(value)) {\n          value = getUntracked(value) || value\n        }\n        let nextValue = value\n        if (Object.getOwnPropertyDescriptor(target, prop)?.set) {\n          // do nothing\n        } else if (value instanceof Promise) {\n          value\n            .then((v) => {\n              Object.assign(value, { status: \"fulfilled\", value: v })\n              notifyUpdate([\"resolve\", [prop], v])\n            })\n            .catch((e) => {\n              Object.assign(value, { status: \"rejected\", reason: e })\n              notifyUpdate([\"reject\", [prop], e])\n            })\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxy(value)\n          }\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue)\n          if (childProxyState) {\n            addPropListener(prop, childProxyState)\n          }\n        }\n        Reflect.set(target, prop, nextValue, receiver)\n        notifyUpdate([\"set\", [prop], value, prevValue])\n        return true\n      },\n    }\n    const proxyObject = newProxy(baseObject, handler)\n    proxyCache.set(initialObject, proxyObject)\n    const proxyState: ProxyState = [baseObject, ensureVersion, createSnapshot, addListener]\n    proxyStateMap.set(proxyObject, proxyState)\n    Reflect.ownKeys(initialObject).forEach((key) => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key) as PropertyDescriptor\n      if (desc.get || desc.set) {\n        Object.defineProperty(baseObject, key, desc)\n      } else {\n        proxyObject[key as keyof T] = initialObject[key as keyof T]\n      }\n    })\n    return proxyObject\n  },\n) =>\n  [\n    // public functions\n    proxyFunction,\n    // shared state\n    proxyStateMap,\n    refSet,\n    // internal things\n    objectIs,\n    newProxy,\n    canProxy,\n    defaultHandlePromise,\n    snapCache,\n    createSnapshot,\n    proxyCache,\n    versionHolder,\n  ] as const\n\nconst [proxyFunction] = buildProxyFunction()\n\nexport function proxy<T extends object>(initialObject: T = {} as T): T {\n  return proxyFunction(initialObject)\n}\n\nexport function getVersion(proxyObject: unknown): number | undefined {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  return proxyState?.[1]()\n}\n\nexport function subscribe<T extends object>(\n  proxyObject: T,\n  callback: (ops: Op[]) => void,\n  notifyInSync?: boolean,\n): () => void {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  let promise: Promise<void> | undefined\n  const ops: Op[] = []\n  const addListener = (proxyState as ProxyState)[3]\n  let isListenerActive = false\n  const listener: Listener = (op) => {\n    ops.push(op)\n    if (notifyInSync) {\n      callback(ops.splice(0))\n      return\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = undefined\n        if (isListenerActive) {\n          callback(ops.splice(0))\n        }\n      })\n    }\n  }\n  const removeListener = addListener(listener)\n  isListenerActive = true\n  return () => {\n    isListenerActive = false\n    removeListener()\n  }\n}\n\nexport function snapshot<T extends object>(proxyObject: T, handlePromise?: HandlePromise): Snapshot<T> {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState as ProxyState\n  return createSnapshot(target, ensureVersion(), handlePromise) as Snapshot<T>\n}\n\nexport function ref<T extends object>(obj: T): Ref<T> {\n  refSet.add(obj)\n  return obj as T & AsRef\n}\n\nexport type Ref<T> = T & AsRef\n","import { proxy, snapshot, type Snapshot } from \"./proxy\"\n\nexport function proxyWithComputed<T extends object, U extends object>(\n  initialObject: T,\n  computedFns: {\n    [K in keyof U]:\n      | ((snap: Snapshot<T>) => U[K])\n      | {\n          get: (snap: Snapshot<T>) => U[K]\n          set?: (state: T, newValue: U[K]) => void\n        }\n  },\n) {\n  const keys = Object.keys(computedFns) as (keyof U)[]\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\")\n    }\n    const computedFn = computedFns[key]\n    const { get, set } = (typeof computedFn === \"function\" ? { get: computedFn } : computedFn) as {\n      get: (snap: Snapshot<T>) => U[typeof key]\n      set?: (state: T, newValue: U[typeof key]) => void\n    }\n    const desc: PropertyDescriptor = {}\n    desc.get = () => get(snapshot(proxyObject))\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue)\n    }\n    Object.defineProperty(initialObject, key, desc)\n  })\n  const proxyObject = proxy(initialObject) as T & U\n  return proxyObject\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}