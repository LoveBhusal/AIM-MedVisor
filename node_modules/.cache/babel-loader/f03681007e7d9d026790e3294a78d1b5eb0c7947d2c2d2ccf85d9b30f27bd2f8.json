{"ast":null,"code":"\"use strict\";\n\nimport { isString } from '../utils/is.js';\nimport { calc } from './calc.js';\nimport { toPx } from './unit-conversion.js';\nconst addNegativeTokens = {\n  enforce: \"pre\",\n  transform(dictionary) {\n    const {\n      prefix,\n      allTokens,\n      formatCssVar,\n      formatTokenName,\n      registerToken\n    } = dictionary;\n    const tokens = allTokens.filter(_ref => {\n      let {\n        extensions\n      } = _ref;\n      return extensions.category === \"spacing\";\n    });\n    tokens.forEach(token => {\n      const originalPath = token.path.slice();\n      const originalVar = formatCssVar(originalPath, prefix);\n      if (isString(token.value) && token.value === \"0rem\") {\n        return;\n      }\n      const nextToken = structuredClone(token);\n      Object.assign(nextToken.extensions, {\n        negative: true,\n        prop: `-${token.extensions.prop}`,\n        originalPath\n      });\n      nextToken.value = calc.negate(originalVar.ref);\n      const lastPath = nextToken.path[nextToken.path.length - 1];\n      if (lastPath != null) {\n        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;\n      }\n      if (nextToken.path) {\n        nextToken.name = formatTokenName(nextToken.path);\n      }\n      registerToken(nextToken);\n    });\n  }\n};\nconst units = /* @__PURE__ */new Set([\"spacing\", \"sizes\", \"borderWidths\", \"fontSizes\", \"radii\"]);\nconst addPixelUnit = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const tokens = dictionary.allTokens.filter(token => {\n      return units.has(token.extensions.category) && !token.extensions.negative;\n    });\n    tokens.forEach(token => {\n      Object.assign(token.extensions, {\n        pixelValue: toPx(token.value)\n      });\n    });\n  }\n};\nconst addVirtualPalette = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const {\n      allTokens,\n      registerToken,\n      formatTokenName\n    } = dictionary;\n    const tokens = allTokens.filter(_ref2 => {\n      let {\n        extensions\n      } = _ref2;\n      return extensions.category === \"colors\";\n    });\n    const keys = /* @__PURE__ */new Map();\n    const colorPalettes = /* @__PURE__ */new Map();\n    tokens.forEach(token => {\n      const {\n        colorPalette\n      } = token.extensions;\n      if (!colorPalette) return;\n      colorPalette.keys.forEach(keyPath => {\n        keys.set(formatTokenName(keyPath), keyPath);\n      });\n      colorPalette.roots.forEach(colorPaletteRoot => {\n        const name = formatTokenName(colorPaletteRoot);\n        const colorPaletteList = colorPalettes.get(name) || [];\n        colorPaletteList.push(token);\n        colorPalettes.set(name, colorPaletteList);\n        if (token.extensions.default && colorPaletteRoot.length === 1) {\n          const keyPath = colorPalette.keys[0]?.filter(Boolean);\n          if (!keyPath.length) return;\n          const path = colorPaletteRoot.concat(keyPath);\n          keys.set(formatTokenName(path), []);\n        }\n      });\n    });\n    keys.forEach(segments => {\n      const path = [\"colors\", \"colorPalette\", ...segments].filter(Boolean);\n      const name = formatTokenName(path);\n      const prop = formatTokenName(path.slice(1));\n      const token = {\n        name,\n        value: name,\n        originalValue: name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category: \"colors\",\n          prop,\n          virtual: true\n        }\n      };\n      registerToken(token, \"pre\");\n    });\n  }\n};\nconst removeEmptyTokens = {\n  enforce: \"post\",\n  transform(dictionary) {\n    dictionary.allTokens = dictionary.allTokens.filter(token => token.value !== \"\");\n  }\n};\nconst tokenMiddlewares = [addNegativeTokens, addVirtualPalette, addPixelUnit, removeEmptyTokens];\nexport { addNegativeTokens, addPixelUnit, addVirtualPalette, removeEmptyTokens, tokenMiddlewares };","map":{"version":3,"names":["isString","calc","toPx","addNegativeTokens","enforce","transform","dictionary","prefix","allTokens","formatCssVar","formatTokenName","registerToken","tokens","filter","_ref","extensions","category","forEach","token","originalPath","path","slice","originalVar","value","nextToken","structuredClone","Object","assign","negative","prop","negate","ref","lastPath","length","name","units","Set","addPixelUnit","has","pixelValue","addVirtualPalette","_ref2","keys","Map","colorPalettes","colorPalette","keyPath","set","roots","colorPaletteRoot","colorPaletteList","get","push","default","Boolean","concat","segments","originalValue","condition","virtual","removeEmptyTokens","tokenMiddlewares"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js"],"sourcesContent":["\"use strict\";\nimport { isString } from '../utils/is.js';\nimport { calc } from './calc.js';\nimport { toPx } from './unit-conversion.js';\n\nconst addNegativeTokens = {\n  enforce: \"pre\",\n  transform(dictionary) {\n    const { prefix, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;\n    const tokens = allTokens.filter(\n      ({ extensions }) => extensions.category === \"spacing\"\n    );\n    tokens.forEach((token) => {\n      const originalPath = token.path.slice();\n      const originalVar = formatCssVar(originalPath, prefix);\n      if (isString(token.value) && token.value === \"0rem\") {\n        return;\n      }\n      const nextToken = structuredClone(token);\n      Object.assign(nextToken.extensions, {\n        negative: true,\n        prop: `-${token.extensions.prop}`,\n        originalPath\n      });\n      nextToken.value = calc.negate(originalVar.ref);\n      const lastPath = nextToken.path[nextToken.path.length - 1];\n      if (lastPath != null) {\n        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;\n      }\n      if (nextToken.path) {\n        nextToken.name = formatTokenName(nextToken.path);\n      }\n      registerToken(nextToken);\n    });\n  }\n};\nconst units = /* @__PURE__ */ new Set([\n  \"spacing\",\n  \"sizes\",\n  \"borderWidths\",\n  \"fontSizes\",\n  \"radii\"\n]);\nconst addPixelUnit = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const tokens = dictionary.allTokens.filter((token) => {\n      return units.has(token.extensions.category) && !token.extensions.negative;\n    });\n    tokens.forEach((token) => {\n      Object.assign(token.extensions, {\n        pixelValue: toPx(token.value)\n      });\n    });\n  }\n};\nconst addVirtualPalette = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const { allTokens, registerToken, formatTokenName } = dictionary;\n    const tokens = allTokens.filter(\n      ({ extensions }) => extensions.category === \"colors\"\n    );\n    const keys = /* @__PURE__ */ new Map();\n    const colorPalettes = /* @__PURE__ */ new Map();\n    tokens.forEach((token) => {\n      const { colorPalette } = token.extensions;\n      if (!colorPalette) return;\n      colorPalette.keys.forEach((keyPath) => {\n        keys.set(formatTokenName(keyPath), keyPath);\n      });\n      colorPalette.roots.forEach((colorPaletteRoot) => {\n        const name = formatTokenName(colorPaletteRoot);\n        const colorPaletteList = colorPalettes.get(name) || [];\n        colorPaletteList.push(token);\n        colorPalettes.set(name, colorPaletteList);\n        if (token.extensions.default && colorPaletteRoot.length === 1) {\n          const keyPath = colorPalette.keys[0]?.filter(Boolean);\n          if (!keyPath.length) return;\n          const path = colorPaletteRoot.concat(keyPath);\n          keys.set(formatTokenName(path), []);\n        }\n      });\n    });\n    keys.forEach((segments) => {\n      const path = [\"colors\", \"colorPalette\", ...segments].filter(Boolean);\n      const name = formatTokenName(path);\n      const prop = formatTokenName(path.slice(1));\n      const token = {\n        name,\n        value: name,\n        originalValue: name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category: \"colors\",\n          prop,\n          virtual: true\n        }\n      };\n      registerToken(token, \"pre\");\n    });\n  }\n};\nconst removeEmptyTokens = {\n  enforce: \"post\",\n  transform(dictionary) {\n    dictionary.allTokens = dictionary.allTokens.filter(\n      (token) => token.value !== \"\"\n    );\n  }\n};\nconst tokenMiddlewares = [\n  addNegativeTokens,\n  addVirtualPalette,\n  addPixelUnit,\n  removeEmptyTokens\n];\n\nexport { addNegativeTokens, addPixelUnit, addVirtualPalette, removeEmptyTokens, tokenMiddlewares };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}