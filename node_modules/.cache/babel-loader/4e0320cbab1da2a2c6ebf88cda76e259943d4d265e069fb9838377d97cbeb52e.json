{"ast":null,"code":"// src/create-anatomy.ts\nvar createAnatomy = function (name) {\n  let parts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return {\n    parts: function () {\n      if (isEmpty(parts)) {\n        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n          values[_key] = arguments[_key];\n        }\n        return createAnatomy(name, values);\n      }\n      throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\");\n    },\n    extendWith: function () {\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n      return createAnatomy(name, [...parts, ...values]);\n    },\n    rename: newName => createAnatomy(newName, parts),\n    keys: () => parts,\n    build: () => [...new Set(parts)].reduce((prev, part) => Object.assign(prev, {\n      [part]: {\n        selector: [`&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`, `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`].join(\", \"),\n        attrs: {\n          \"data-scope\": toKebabCase(name),\n          \"data-part\": toKebabCase(part)\n        }\n      }\n    }), {})\n  };\n};\nvar toKebabCase = value => value.replace(/([A-Z])([A-Z])/g, \"$1-$2\").replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[\\s_]+/g, \"-\").toLowerCase();\nvar isEmpty = v => v.length === 0;\nexport { createAnatomy };","map":{"version":3,"names":["createAnatomy","name","parts","arguments","length","undefined","isEmpty","_len","values","Array","_key","Error","extendWith","_len2","_key2","rename","newName","keys","build","Set","reduce","prev","part","Object","assign","selector","toKebabCase","join","attrs","value","replace","toLowerCase","v"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/anatomy/src/create-anatomy.ts"],"sourcesContent":["export interface AnatomyPart {\n  selector: string\n  attrs: Record<\"data-scope\" | \"data-part\", string>\n}\n\nexport type AnatomyInstance<T extends string> = Omit<Anatomy<T>, \"parts\">\n\nexport type AnatomyPartName<T> = T extends AnatomyInstance<infer U> ? U : never\n\nexport interface Anatomy<T extends string> {\n  parts: <U extends string>(...parts: U[]) => AnatomyInstance<U>\n  extendWith: <V extends string>(...parts: V[]) => AnatomyInstance<T | V>\n  build: () => Record<T, AnatomyPart>\n  rename: (newName: string) => Anatomy<T>\n  keys: () => T[]\n}\n\nexport const createAnatomy = <T extends string>(name: string, parts = [] as T[]): Anatomy<T> => ({\n  parts: (...values) => {\n    if (isEmpty(parts)) {\n      return createAnatomy(name, values)\n    }\n    throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\")\n  },\n  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),\n  rename: (newName) => createAnatomy(newName, parts),\n  keys: () => parts,\n  build: () =>\n    [...new Set(parts)].reduce<Record<string, AnatomyPart>>(\n      (prev, part) =>\n        Object.assign(prev, {\n          [part]: {\n            selector: [\n              `&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n              `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n            ].join(\", \"),\n            attrs: { \"data-scope\": toKebabCase(name), \"data-part\": toKebabCase(part) },\n          },\n        }),\n      {},\n    ),\n})\n\nconst toKebabCase = (value: string) =>\n  value\n    .replace(/([A-Z])([A-Z])/g, \"$1-$2\")\n    .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n    .replace(/[\\s_]+/g, \"-\")\n    .toLowerCase()\n\nconst isEmpty = <T>(v: T[]): boolean => v.length === 0\n"],"mappings":";AAiBO,IAAMA,aAAA,GAAgB,SAAAA,CAAmBC,IAAA;EAAA,IAAcC,KAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAQ,EAAC;EAAA,OAA0B;IAC/FD,KAAA,EAAO,SAAAA,CAAA,EAAe;MACpB,IAAII,OAAA,CAAQJ,KAAK,GAAG;QAAA,SAAAK,IAAA,GAAAJ,SAAA,CAAAC,MAAA,EADXI,MAAA,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;UAAAF,MAAA,CAAAE,IAAA,IAAAP,SAAA,CAAAO,IAAA;QAAA;QAEP,OAAOV,aAAA,CAAcC,IAAA,EAAMO,MAAM;MACnC;MACA,MAAM,IAAIG,KAAA,CAAM,+FAA+F;IACjH;IACAC,UAAA,EAAY,SAAAA,CAAA;MAAA,SAAAC,KAAA,GAAAV,SAAA,CAAAC,MAAA,EAAII,MAAA,OAAAC,KAAA,CAAAI,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAAN,MAAA,CAAAM,KAAA,IAAAX,SAAA,CAAAW,KAAA;MAAA;MAAA,OAAWd,aAAA,CAAcC,IAAA,EAAM,CAAC,GAAGC,KAAA,EAAO,GAAGM,MAAM,CAAC;IAAA;IACpEO,MAAA,EAASC,OAAA,IAAYhB,aAAA,CAAcgB,OAAA,EAASd,KAAK;IACjDe,IAAA,EAAMA,CAAA,KAAMf,KAAA;IACZgB,KAAA,EAAOA,CAAA,KACL,CAAC,GAAG,IAAIC,GAAA,CAAIjB,KAAK,CAAC,EAAEkB,MAAA,CAClB,CAACC,IAAA,EAAMC,IAAA,KACLC,MAAA,CAAOC,MAAA,CAAOH,IAAA,EAAM;MAClB,CAACC,IAAI,GAAG;QACNG,QAAA,EAAU,CACR,iBAAiBC,WAAA,CAAYzB,IAAI,CAAC,iBAAiByB,WAAA,CAAYJ,IAAI,CAAC,MACpE,kBAAkBI,WAAA,CAAYzB,IAAI,CAAC,iBAAiByB,WAAA,CAAYJ,IAAI,CAAC,KACvE,CAAEK,IAAA,CAAK,IAAI;QACXC,KAAA,EAAO;UAAE,cAAcF,WAAA,CAAYzB,IAAI;UAAG,aAAayB,WAAA,CAAYJ,IAAI;QAAE;MAC3E;IACF,CAAC,GACH,CAAC,CACH;EACJ;AAAA;AAEA,IAAMI,WAAA,GAAeG,KAAA,IACnBA,KAAA,CACGC,OAAA,CAAQ,mBAAmB,OAAO,EAClCA,OAAA,CAAQ,mBAAmB,OAAO,EAClCA,OAAA,CAAQ,WAAW,GAAG,EACtBC,WAAA,CAAY;AAEjB,IAAMzB,OAAA,GAAc0B,CAAA,IAAoBA,CAAA,CAAE5B,MAAA,KAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}