{"ast":null,"code":"// src/toast-group.connect.ts\nimport { isMachine, subscribe } from \"@zag-js/core\";\nimport { contains } from \"@zag-js/dom-query\";\nimport { runIfFn, uuid } from \"@zag-js/utils\";\n\n// src/toast.anatomy.ts\nimport { createAnatomy } from \"@zag-js/anatomy\";\nvar anatomy = createAnatomy(\"toast\").parts(\"group\", \"root\", \"title\", \"description\", \"actionTrigger\", \"closeTrigger\");\nvar parts = anatomy.build();\n\n// src/toast.dom.ts\nimport { createScope } from \"@zag-js/dom-query\";\nvar dom = createScope({\n  getRegionId: placement => `toast-group:${placement}`,\n  getRegionEl: (ctx, placement) => dom.getById(ctx, `toast-group:${placement}`),\n  getRootId: ctx => `toast:${ctx.id}`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getTitleId: ctx => `toast:${ctx.id}:title`,\n  getDescriptionId: ctx => `toast:${ctx.id}:description`,\n  getCloseTriggerId: ctx => `toast${ctx.id}:close`\n});\n\n// src/toast.utils.ts\nimport { MAX_Z_INDEX } from \"@zag-js/dom-query\";\nfunction getToastsByPlacement(toasts, placement) {\n  return toasts.filter(toast => toast.state.context.placement === placement);\n}\nvar defaultTimeouts = {\n  info: 5e3,\n  error: 5e3,\n  success: 2e3,\n  loading: Infinity,\n  DEFAULT: 5e3\n};\nfunction getToastDuration(duration, type) {\n  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;\n}\nfunction getGroupPlacementStyle(ctx, placement) {\n  const offset = ctx.offsets;\n  const computedOffset = typeof offset === \"string\" ? {\n    left: offset,\n    right: offset,\n    bottom: offset,\n    top: offset\n  } : offset;\n  const rtl = ctx.dir === \"rtl\";\n  const computedPlacement = placement.replace(\"-start\", rtl ? \"-right\" : \"-left\").replace(\"-end\", rtl ? \"-left\" : \"-right\");\n  const isRighty = computedPlacement.includes(\"right\");\n  const isLefty = computedPlacement.includes(\"left\");\n  const styles = {\n    position: \"fixed\",\n    pointerEvents: ctx.count > 0 ? void 0 : \"none\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"--gap\": `${ctx.gap}px`,\n    \"--first-height\": `${ctx.heights[0]?.height || 0}px`,\n    zIndex: MAX_Z_INDEX\n  };\n  let alignItems = \"center\";\n  if (isRighty) alignItems = \"flex-end\";\n  if (isLefty) alignItems = \"flex-start\";\n  styles.alignItems = alignItems;\n  if (computedPlacement.includes(\"top\")) {\n    const offset2 = computedOffset.top;\n    styles.top = `max(env(safe-area-inset-top, 0px), ${offset2})`;\n  }\n  if (computedPlacement.includes(\"bottom\")) {\n    const offset2 = computedOffset.bottom;\n    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset2})`;\n  }\n  if (!computedPlacement.includes(\"left\")) {\n    const offset2 = computedOffset.right;\n    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset2})`;\n  }\n  if (!computedPlacement.includes(\"right\")) {\n    const offset2 = computedOffset.left;\n    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset2})`;\n  }\n  return styles;\n}\nfunction getPlacementStyle(ctx, visible) {\n  const [side] = ctx.placement.split(\"-\");\n  const sibling = !ctx.frontmost;\n  const overlap = !ctx.stacked;\n  const styles = {\n    position: \"absolute\",\n    pointerEvents: \"auto\",\n    \"--opacity\": \"0\",\n    \"--remove-delay\": `${ctx.removeDelay}ms`,\n    \"--duration\": `${ctx.type === \"loading\" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,\n    \"--initial-height\": `${ctx.height}px`,\n    \"--offset\": `${ctx.offset}px`,\n    \"--index\": ctx.index,\n    \"--z-index\": ctx.zIndex,\n    \"--lift-amount\": \"calc(var(--lift) * var(--gap))\",\n    \"--y\": \"100%\",\n    \"--x\": \"0\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (side === \"top\") {\n    assign({\n      top: \"0\",\n      \"--sign\": \"-1\",\n      \"--y\": \"-100%\",\n      \"--lift\": \"1\"\n    });\n  } else if (side === \"bottom\") {\n    assign({\n      bottom: \"0\",\n      \"--sign\": \"1\",\n      \"--y\": \"100%\",\n      \"--lift\": \"-1\"\n    });\n  }\n  if (ctx.mounted) {\n    assign({\n      \"--y\": \"0\",\n      \"--opacity\": \"1\"\n    });\n    if (ctx.stacked) {\n      assign({\n        \"--y\": \"calc(var(--lift) * var(--offset))\",\n        \"--height\": \"var(--initial-height)\"\n      });\n    }\n  }\n  if (!visible) {\n    assign({\n      \"--opacity\": \"0\",\n      pointerEvents: \"none\"\n    });\n  }\n  if (sibling && overlap) {\n    assign({\n      \"--base-scale\": \"var(--index) * 0.05 + 1\",\n      \"--y\": \"calc(var(--lift-amount) * var(--index))\",\n      \"--scale\": \"calc(-1 * var(--base-scale))\",\n      \"--height\": \"var(--first-height)\"\n    });\n    if (!visible) {\n      assign({\n        \"--y\": \"calc(var(--sign) * 40%)\"\n      });\n    }\n  }\n  if (sibling && ctx.stacked && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * var(--offset) + var(--lift) * -100%)\"\n    });\n  }\n  if (ctx.frontmost && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * -100%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostBeforeStyle(ctx, visible) {\n  const styles = {\n    position: \"absolute\",\n    inset: \"0\",\n    scale: \"1 2\",\n    pointerEvents: visible ? \"none\" : \"auto\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (ctx.frontmost && !visible) {\n    assign({\n      height: \"calc(var(--initial-height) + 80%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostAfterStyle(_ctx, _visible) {\n  return {\n    position: \"absolute\",\n    left: \"0\",\n    height: \"calc(var(--gap) + 2px)\",\n    bottom: \"100%\",\n    width: \"100%\"\n  };\n}\n\n// src/toast-group.connect.ts\nfunction groupConnect(serviceOrState, send, normalize) {\n  function getState() {\n    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState;\n    return result;\n  }\n  function getToastsByPlacementImpl(placement) {\n    return getToastsByPlacement(getState().context.toasts, placement);\n  }\n  function isVisible(id) {\n    const toasts = getState().context.toasts;\n    if (!toasts.length) return false;\n    return !!toasts.find(toast => toast.id == id);\n  }\n  function create(options) {\n    const uid = `toast:${uuid()}`;\n    const id = options.id ? options.id : uid;\n    if (isVisible(id)) return id;\n    send({\n      type: \"ADD_TOAST\",\n      toast: {\n        ...options,\n        id\n      }\n    });\n    return id;\n  }\n  function update(id, options) {\n    if (!isVisible(id)) return id;\n    send({\n      type: \"UPDATE_TOAST\",\n      id,\n      toast: options\n    });\n    return id;\n  }\n  function upsert(options) {\n    const {\n      id\n    } = options;\n    const visible = id ? isVisible(id) : false;\n    if (visible && id != null) {\n      return update(id, options);\n    } else {\n      return create(options);\n    }\n  }\n  function dismiss(id) {\n    if (id == null) {\n      send(\"DISMISS_ALL\");\n    } else if (isVisible(id)) {\n      send({\n        type: \"DISMISS_TOAST\",\n        id\n      });\n    }\n  }\n  return {\n    getCount() {\n      return getState().context.count;\n    },\n    getPlacements() {\n      const toasts = getState().context.toasts;\n      const placements = toasts.map(toast => toast.state.context.placement);\n      return Array.from(new Set(placements));\n    },\n    getToastsByPlacement: getToastsByPlacementImpl,\n    isVisible,\n    create,\n    update,\n    upsert,\n    dismiss,\n    remove(id) {\n      if (id == null) {\n        send(\"REMOVE_ALL\");\n      } else if (isVisible(id)) {\n        send({\n          type: \"REMOVE_TOAST\",\n          id\n        });\n      }\n    },\n    dismissByPlacement(placement) {\n      const toasts = getToastsByPlacementImpl(placement);\n      toasts.forEach(toast => dismiss(toast.id));\n    },\n    loading(options) {\n      return upsert({\n        ...options,\n        type: \"loading\"\n      });\n    },\n    success(options) {\n      return upsert({\n        ...options,\n        type: \"success\"\n      });\n    },\n    error(options) {\n      return upsert({\n        ...options,\n        type: \"error\"\n      });\n    },\n    promise(promise, options) {\n      let shared = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      const id = upsert({\n        ...shared,\n        ...options.loading,\n        type: \"loading\"\n      });\n      runIfFn(promise).then(response => {\n        const successOptions = runIfFn(options.success, response);\n        upsert({\n          ...shared,\n          ...successOptions,\n          id,\n          type: \"success\"\n        });\n      }).catch(error => {\n        const errorOptions = runIfFn(options.error, error);\n        upsert({\n          ...shared,\n          ...errorOptions,\n          id,\n          type: \"error\"\n        });\n      }).finally(() => {\n        options.finally?.();\n      });\n      return id;\n    },\n    pause(id) {\n      if (id == null) {\n        send(\"PAUSE_ALL\");\n      } else if (isVisible(id)) {\n        send({\n          type: \"PAUSE_TOAST\",\n          id\n        });\n      }\n    },\n    resume(id) {\n      if (id == null) {\n        send(\"RESUME_ALL\");\n      } else if (isVisible(id)) {\n        send({\n          type: \"RESUME_TOAST\",\n          id\n        });\n      }\n    },\n    getGroupProps(options) {\n      const {\n        placement,\n        label = \"Notifications\"\n      } = options;\n      const state = getState();\n      const hotkeyLabel = state.context.hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n      const [side, align = \"center\"] = placement.split(\"-\");\n      return normalize.element({\n        ...parts.group.attrs,\n        dir: state.context.dir,\n        tabIndex: -1,\n        \"aria-label\": `${placement} ${label} ${hotkeyLabel}`,\n        id: dom.getRegionId(placement),\n        \"data-placement\": placement,\n        \"data-side\": side,\n        \"data-align\": align,\n        \"aria-live\": \"polite\",\n        role: \"region\",\n        style: getGroupPlacementStyle(state.context, placement),\n        onMouseMove() {\n          send({\n            type: \"REGION.POINTER_ENTER\",\n            placement\n          });\n        },\n        onMouseLeave() {\n          send({\n            type: \"REGION.POINTER_LEAVE\",\n            placement\n          });\n        },\n        onFocus(event) {\n          send({\n            type: \"REGION.FOCUS\",\n            target: event.relatedTarget\n          });\n        },\n        onBlur(event) {\n          if (state.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {\n            send({\n              type: \"REGION.BLUR\"\n            });\n          }\n        }\n      });\n    },\n    subscribe(fn) {\n      const state = getState();\n      return subscribe(state.context.toasts, () => {\n        const toasts = getToastsByPlacementImpl(state.context.placement);\n        const contexts = toasts.map(toast => toast.getState().context);\n        fn(contexts);\n      });\n    }\n  };\n}\n\n// src/toast-group.machine.ts\nimport { createMachine as createMachine2, ref } from \"@zag-js/core\";\nimport { trackDismissableBranch } from \"@zag-js/dismissable\";\nimport { addDomEvent } from \"@zag-js/dom-event\";\nimport { compact as compact2 } from \"@zag-js/utils\";\n\n// src/toast.machine.ts\nimport { createMachine, guards } from \"@zag-js/core\";\nimport { queryAll, raf } from \"@zag-js/dom-query\";\nimport { compact, warn } from \"@zag-js/utils\";\nvar {\n  not,\n  and,\n  or\n} = guards;\nfunction createToastMachine(options) {\n  const {\n    type = \"info\",\n    duration,\n    id = \"1\",\n    placement = \"bottom\",\n    removeDelay = 200,\n    ...restProps\n  } = options;\n  const ctx = compact(restProps);\n  const computedDuration = getToastDuration(duration, type);\n  return createMachine({\n    id,\n    context: {\n      id,\n      type,\n      remaining: computedDuration,\n      duration: computedDuration,\n      removeDelay,\n      createdAt: Date.now(),\n      placement,\n      ...ctx,\n      height: 0,\n      offset: 0,\n      frontmost: false,\n      mounted: false,\n      index: -1,\n      zIndex: 0\n    },\n    initial: type === \"loading\" ? \"visible:persist\" : \"visible\",\n    on: {\n      UPDATE: [{\n        guard: and(\"hasTypeChanged\", \"isChangingToLoading\"),\n        target: \"visible:persist\",\n        actions: [\"setContext\"]\n      }, {\n        guard: or(\"hasDurationChanged\", \"hasTypeChanged\"),\n        target: \"visible:updating\",\n        actions: [\"setContext\"]\n      }, {\n        actions: [\"setContext\"]\n      }],\n      MEASURE: {\n        actions: [\"measureHeight\"]\n      }\n    },\n    entry: [\"invokeOnVisible\"],\n    activities: [\"trackHeight\"],\n    states: {\n      \"visible:updating\": {\n        tags: [\"visible\", \"updating\"],\n        after: {\n          0: \"visible\"\n        }\n      },\n      \"visible:persist\": {\n        tags: [\"visible\", \"paused\"],\n        on: {\n          RESUME: {\n            guard: not(\"isLoadingType\"),\n            target: \"visible\",\n            actions: [\"setCreatedAt\"]\n          },\n          DISMISS: \"dismissing\"\n        }\n      },\n      visible: {\n        tags: [\"visible\"],\n        after: {\n          VISIBLE_DURATION: \"dismissing\"\n        },\n        on: {\n          DISMISS: \"dismissing\",\n          PAUSE: {\n            target: \"visible:persist\",\n            actions: \"setRemainingDuration\"\n          }\n        }\n      },\n      dismissing: {\n        entry: \"invokeOnDismiss\",\n        after: {\n          REMOVE_DELAY: {\n            target: \"unmounted\",\n            actions: \"notifyParentToRemove\"\n          }\n        }\n      },\n      unmounted: {\n        entry: \"invokeOnUnmount\",\n        type: \"final\"\n      }\n    }\n  }, {\n    activities: {\n      trackHeight(ctx2, _evt, _ref) {\n        let {\n          self\n        } = _ref;\n        let cleanup;\n        raf(() => {\n          const rootEl = dom.getRootEl(ctx2);\n          if (!rootEl) return;\n          ctx2.mounted = true;\n          const ghosts = queryAll(rootEl, \"[data-ghost]\");\n          warn(ghosts.length !== 2, \"[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements\");\n          const syncHeight = () => {\n            const originalHeight = rootEl.style.height;\n            rootEl.style.height = \"auto\";\n            const newHeight = rootEl.getBoundingClientRect().height;\n            rootEl.style.height = originalHeight;\n            ctx2.height = newHeight;\n            self.sendParent({\n              type: \"UPDATE_HEIGHT\",\n              id: self.id,\n              height: newHeight,\n              placement: ctx2.placement\n            });\n          };\n          syncHeight();\n          const win = dom.getWin(ctx2);\n          const observer = new win.MutationObserver(syncHeight);\n          observer.observe(rootEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n          });\n          cleanup = () => observer.disconnect();\n        });\n        return () => cleanup?.();\n      }\n    },\n    guards: {\n      isChangingToLoading: (_, evt) => evt.toast?.type === \"loading\",\n      isLoadingType: ctx2 => ctx2.type === \"loading\",\n      hasTypeChanged: (ctx2, evt) => evt.toast?.type != null && evt.toast.type !== ctx2.type,\n      hasDurationChanged: (ctx2, evt) => evt.toast?.duration != null && evt.toast.duration !== ctx2.duration\n    },\n    delays: {\n      VISIBLE_DURATION: ctx2 => ctx2.remaining,\n      REMOVE_DELAY: ctx2 => ctx2.removeDelay\n    },\n    actions: {\n      measureHeight(ctx2, _evt, _ref2) {\n        let {\n          self\n        } = _ref2;\n        raf(() => {\n          const rootEl = dom.getRootEl(ctx2);\n          if (!rootEl) return;\n          ctx2.mounted = true;\n          const originalHeight = rootEl.style.height;\n          rootEl.style.height = \"auto\";\n          const newHeight = rootEl.getBoundingClientRect().height;\n          rootEl.style.height = originalHeight;\n          ctx2.height = newHeight;\n          self.sendParent({\n            type: \"UPDATE_HEIGHT\",\n            id: self.id,\n            height: newHeight,\n            placement: ctx2.placement\n          });\n        });\n      },\n      setRemainingDuration(ctx2) {\n        ctx2.remaining -= Date.now() - ctx2.createdAt;\n      },\n      setCreatedAt(ctx2) {\n        ctx2.createdAt = Date.now();\n      },\n      notifyParentToRemove(_ctx, _evt, _ref3) {\n        let {\n          self\n        } = _ref3;\n        self.sendParent({\n          type: \"REMOVE_TOAST\",\n          id: self.id\n        });\n      },\n      invokeOnDismiss(ctx2) {\n        ctx2.onStatusChange?.({\n          status: \"dismissing\"\n        });\n      },\n      invokeOnUnmount(ctx2) {\n        ctx2.onStatusChange?.({\n          status: \"unmounted\"\n        });\n      },\n      invokeOnVisible(ctx2) {\n        ctx2.onStatusChange?.({\n          status: \"visible\"\n        });\n      },\n      setContext(ctx2, evt) {\n        const duration2 = evt.toast?.duration;\n        const type2 = evt.toast?.type ?? ctx2.type;\n        const computedDuration2 = getToastDuration(duration2, type2);\n        Object.assign(ctx2, {\n          ...evt.toast,\n          duration: computedDuration2,\n          remaining: computedDuration2\n        });\n      }\n    }\n  });\n}\n\n// src/toast-group.machine.ts\nfunction groupMachine(userContext) {\n  const ctx = compact2(userContext);\n  return createMachine2({\n    id: \"toaster\",\n    initial: ctx.overlap ? \"overlap\" : \"stack\",\n    context: {\n      dir: \"ltr\",\n      max: Number.MAX_SAFE_INTEGER,\n      gap: 16,\n      pauseOnPageIdle: false,\n      hotkey: [\"altKey\", \"KeyT\"],\n      offsets: \"1rem\",\n      placement: \"bottom\",\n      removeDelay: 200,\n      ...ctx,\n      toasts: [],\n      lastFocusedEl: null,\n      isFocusWithin: false,\n      heights: []\n    },\n    computed: {\n      count: ctx2 => ctx2.toasts.length\n    },\n    activities: [\"trackDocumentVisibility\", \"trackHotKeyPress\"],\n    watch: {\n      toasts: [\"collapsedIfEmpty\", \"setDismissableBranch\"]\n    },\n    exit: [\"removeToasts\", \"clearDismissableBranch\", \"clearLastFocusedEl\"],\n    on: {\n      PAUSE_TOAST: {\n        actions: [\"pauseToast\"]\n      },\n      PAUSE_ALL: {\n        actions: [\"pauseToasts\"]\n      },\n      RESUME_TOAST: {\n        actions: [\"resumeToast\"]\n      },\n      RESUME_ALL: {\n        actions: [\"resumeToasts\"]\n      },\n      ADD_TOAST: {\n        guard: \"isWithinRange\",\n        actions: [\"createToast\", \"syncToastIndex\"]\n      },\n      UPDATE_TOAST: {\n        actions: [\"updateToast\"]\n      },\n      DISMISS_TOAST: {\n        actions: [\"dismissToast\"]\n      },\n      DISMISS_ALL: {\n        actions: [\"dismissToasts\"]\n      },\n      REMOVE_TOAST: {\n        actions: [\"removeToast\", \"syncToastIndex\", \"syncToastOffset\"]\n      },\n      REMOVE_ALL: {\n        actions: [\"removeToasts\"]\n      },\n      UPDATE_HEIGHT: {\n        actions: [\"syncHeights\", \"syncToastOffset\"]\n      },\n      \"DOC.HOTKEY\": {\n        actions: [\"focusRegionEl\"]\n      },\n      \"REGION.BLUR\": [{\n        guard: \"isOverlapping\",\n        target: \"overlap\",\n        actions: [\"resumeToasts\", \"restoreLastFocusedEl\"]\n      }, {\n        actions: [\"resumeToasts\", \"restoreLastFocusedEl\"]\n      }]\n    },\n    states: {\n      stack: {\n        entry: [\"expandToasts\"],\n        on: {\n          \"REGION.POINTER_LEAVE\": [{\n            guard: \"isOverlapping\",\n            target: \"overlap\",\n            actions: [\"resumeToasts\"]\n          }, {\n            actions: [\"resumeToasts\"]\n          }],\n          \"REGION.OVERLAP\": {\n            target: \"overlap\"\n          },\n          \"REGION.FOCUS\": {\n            actions: [\"setLastFocusedEl\", \"pauseToasts\"]\n          },\n          \"REGION.POINTER_ENTER\": {\n            actions: [\"pauseToasts\"]\n          }\n        }\n      },\n      overlap: {\n        entry: [\"collapseToasts\"],\n        on: {\n          \"REGION.STACK\": {\n            target: \"stack\"\n          },\n          \"REGION.POINTER_ENTER\": {\n            target: \"stack\",\n            actions: [\"pauseToasts\"]\n          },\n          \"REGION.FOCUS\": {\n            target: \"stack\",\n            actions: [\"setLastFocusedEl\", \"pauseToasts\"]\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      isWithinRange: ctx2 => ctx2.toasts.length < ctx2.max,\n      isOverlapping: ctx2 => !!ctx2.overlap\n    },\n    activities: {\n      trackHotKeyPress(ctx2, _evt, _ref4) {\n        let {\n          send\n        } = _ref4;\n        const handleKeyDown = event => {\n          const isHotkeyPressed = ctx2.hotkey.every(key => event[key] || event.code === key);\n          if (!isHotkeyPressed) return;\n          send({\n            type: \"DOC.HOTKEY\"\n          });\n        };\n        return addDomEvent(document, \"keydown\", handleKeyDown, {\n          capture: true\n        });\n      },\n      trackDocumentVisibility(ctx2, _evt, _ref5) {\n        let {\n          send\n        } = _ref5;\n        if (!ctx2.pauseOnPageIdle) return;\n        const doc = dom.getDoc(ctx2);\n        return addDomEvent(doc, \"visibilitychange\", () => {\n          send(doc.visibilityState === \"hidden\" ? \"PAUSE_ALL\" : \"RESUME_ALL\");\n        });\n      }\n    },\n    actions: {\n      setDismissableBranch(ctx2) {\n        const currentToasts = getToastsByPlacement(ctx2.toasts, ctx2.placement);\n        const hasToasts = currentToasts.length > 0;\n        if (!hasToasts) {\n          ctx2._cleanup?.();\n          return;\n        }\n        if (hasToasts && ctx2._cleanup) {\n          return;\n        }\n        const groupEl = () => dom.getRegionEl(ctx2, ctx2.placement);\n        ctx2._cleanup = trackDismissableBranch(groupEl, {\n          defer: true\n        });\n      },\n      clearDismissableBranch(ctx2) {\n        ctx2._cleanup?.();\n      },\n      focusRegionEl(ctx2) {\n        queueMicrotask(() => {\n          dom.getRegionEl(ctx2, ctx2.placement)?.focus();\n        });\n      },\n      expandToasts(ctx2) {\n        each(ctx2, toast => {\n          toast.state.context.stacked = true;\n        });\n      },\n      collapseToasts(ctx2) {\n        each(ctx2, toast => {\n          toast.state.context.stacked = false;\n        });\n      },\n      collapsedIfEmpty(ctx2, _evt, _ref6) {\n        let {\n          send\n        } = _ref6;\n        if (!ctx2.overlap || ctx2.toasts.length > 1) return;\n        send(\"REGION.OVERLAP\");\n      },\n      pauseToast(_ctx, evt, _ref7) {\n        let {\n          self\n        } = _ref7;\n        self.sendChild(\"PAUSE\", evt.id);\n      },\n      pauseToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"PAUSE\"));\n      },\n      resumeToast(_ctx, evt, _ref8) {\n        let {\n          self\n        } = _ref8;\n        self.sendChild(\"RESUME\", evt.id);\n      },\n      resumeToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"RESUME\"));\n      },\n      measureToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"MEASURE\"));\n      },\n      createToast(ctx2, evt, _ref9) {\n        let {\n          self,\n          getState\n        } = _ref9;\n        const options = {\n          placement: ctx2.placement,\n          duration: ctx2.duration,\n          removeDelay: ctx2.removeDelay,\n          ...evt.toast,\n          dir: ctx2.dir,\n          getRootNode: ctx2.getRootNode,\n          stacked: getState().matches(\"stack\")\n        };\n        const toast = createToastMachine(options);\n        const actor = self.spawn(toast);\n        ctx2.toasts = [actor, ...ctx2.toasts];\n      },\n      updateToast(_ctx, evt, _ref10) {\n        let {\n          self\n        } = _ref10;\n        self.sendChild({\n          type: \"UPDATE\",\n          toast: evt.toast\n        }, evt.id);\n      },\n      dismissToast(_ctx, evt, _ref11) {\n        let {\n          self\n        } = _ref11;\n        self.sendChild(\"DISMISS\", evt.id);\n      },\n      dismissToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"DISMISS\"));\n      },\n      removeToast(ctx2, evt, _ref12) {\n        let {\n          self\n        } = _ref12;\n        self.stopChild(evt.id);\n        ctx2.toasts = ctx2.toasts.filter(toast => toast.id !== evt.id);\n        ctx2.heights = ctx2.heights.filter(height => height.id !== evt.id);\n      },\n      removeToasts(ctx2, _evt, _ref13) {\n        let {\n          self\n        } = _ref13;\n        ctx2.toasts.forEach(toast => self.stopChild(toast.id));\n        ctx2.toasts = [];\n        ctx2.heights = [];\n      },\n      syncHeights(ctx2, evt) {\n        const existing = ctx2.heights.find(height => height.id === evt.id);\n        if (existing) {\n          existing.height = evt.height;\n          existing.placement = evt.placement;\n        } else {\n          const newHeight = {\n            id: evt.id,\n            height: evt.height,\n            placement: evt.placement\n          };\n          ctx2.heights = [newHeight, ...ctx2.heights];\n        }\n      },\n      syncToastIndex(ctx2) {\n        each(ctx2, (toast, index, toasts) => {\n          toast.state.context.index = index;\n          toast.state.context.frontmost = index === 0;\n          toast.state.context.zIndex = toasts.length - index;\n        });\n      },\n      syncToastOffset(ctx2, evt) {\n        const placement = evt.placement ?? ctx2.placement;\n        each({\n          ...ctx2,\n          placement\n        }, toast => {\n          const heightIndex = Math.max(ctx2.heights.findIndex(height => height.id === toast.id), 0);\n          const toastsHeightBefore = ctx2.heights.reduce((prev, curr, reducerIndex) => {\n            if (reducerIndex >= heightIndex) return prev;\n            return prev + curr.height;\n          }, 0);\n          toast.state.context.offset = heightIndex * ctx2.gap + toastsHeightBefore;\n        });\n      },\n      setLastFocusedEl(ctx2, evt) {\n        if (ctx2.isFocusWithin || !evt.target) return;\n        ctx2.isFocusWithin = true;\n        ctx2.lastFocusedEl = ref(evt.target);\n      },\n      restoreLastFocusedEl(ctx2) {\n        ctx2.isFocusWithin = false;\n        if (!ctx2.lastFocusedEl) return;\n        ctx2.lastFocusedEl.focus({\n          preventScroll: true\n        });\n        ctx2.lastFocusedEl = null;\n      },\n      clearLastFocusedEl(ctx2) {\n        if (!ctx2.lastFocusedEl) return;\n        ctx2.lastFocusedEl.focus({\n          preventScroll: true\n        });\n        ctx2.lastFocusedEl = null;\n        ctx2.isFocusWithin = false;\n      }\n    }\n  });\n}\nfunction each(ctx, fn) {\n  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement);\n  currentToasts.forEach(fn);\n}\n\n// src/toast.connect.ts\nimport { dataAttr } from \"@zag-js/dom-query\";\nfunction connect(state, send, normalize) {\n  const visible = state.hasTag(\"visible\");\n  const paused = state.hasTag(\"paused\");\n  const placement = state.context.placement;\n  const type = state.context.type;\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return {\n    type,\n    title: state.context.title,\n    description: state.context.description,\n    placement,\n    visible,\n    paused,\n    pause() {\n      send(\"PAUSE\");\n    },\n    resume() {\n      send(\"RESUME\");\n    },\n    dismiss() {\n      send(\"DISMISS\");\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-state\": visible ? \"open\" : \"closed\",\n        \"data-type\": type,\n        \"data-placement\": placement,\n        \"data-align\": align,\n        \"data-side\": side,\n        \"data-mounted\": dataAttr(state.context.mounted),\n        \"data-paused\": dataAttr(paused),\n        \"data-first\": dataAttr(state.context.frontmost),\n        \"data-sibling\": dataAttr(!state.context.frontmost),\n        \"data-stack\": dataAttr(state.context.stacked),\n        \"data-overlap\": dataAttr(!state.context.stacked),\n        role: \"status\",\n        \"aria-atomic\": \"true\",\n        \"aria-describedby\": state.context.description ? dom.getDescriptionId(state.context) : void 0,\n        \"aria-labelledby\": state.context.title ? dom.getTitleId(state.context) : void 0,\n        tabIndex: 0,\n        style: getPlacementStyle(state.context, visible),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (event.key == \"Escape\") {\n            send(\"DISMISS\");\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    /* Leave a ghost div to avoid setting hover to false when transitioning out */\n    getGhostBeforeProps() {\n      return normalize.element({\n        \"data-ghost\": \"before\",\n        style: getGhostBeforeStyle(state.context, visible)\n      });\n    },\n    /* Needed to avoid setting hover to false when in between toasts */\n    getGhostAfterProps() {\n      return normalize.element({\n        \"data-ghost\": \"after\",\n        style: getGhostAfterStyle(state.context, visible)\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: dom.getTitleId(state.context)\n      });\n    },\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: dom.getDescriptionId(state.context)\n      });\n    },\n    getActionTriggerProps() {\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"DISMISS\");\n        }\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        id: dom.getCloseTriggerId(state.context),\n        ...parts.closeTrigger.attrs,\n        type: \"button\",\n        \"aria-label\": \"Dismiss notification\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"DISMISS\");\n        }\n      });\n    }\n  };\n}\n\n// src/index.ts\nvar group = {\n  connect: groupConnect,\n  machine: groupMachine\n};\nexport { anatomy, connect, createToastMachine as createMachine, group };","map":{"version":3,"names":["isMachine","subscribe","contains","runIfFn","uuid","createAnatomy","anatomy","parts","build","createScope","dom","getRegionId","placement","getRegionEl","ctx","getById","getRootId","id","getRootEl","getTitleId","getDescriptionId","getCloseTriggerId","MAX_Z_INDEX","getToastsByPlacement","toasts","filter","toast","state","context","defaultTimeouts","info","error","success","loading","Infinity","DEFAULT","getToastDuration","duration","type","getGroupPlacementStyle","offset","offsets","computedOffset","left","right","bottom","top","rtl","dir","computedPlacement","replace","isRighty","includes","isLefty","styles","position","pointerEvents","count","display","flexDirection","gap","heights","height","zIndex","alignItems","offset2","insetInlineEnd","insetInlineStart","getPlacementStyle","visible","side","split","sibling","frontmost","overlap","stacked","removeDelay","Number","MAX_SAFE_INTEGER","index","assign","overrides","Object","mounted","getGhostBeforeStyle","inset","scale","getGhostAfterStyle","_ctx","_visible","width","groupConnect","serviceOrState","send","normalize","getState","result","getToastsByPlacementImpl","isVisible","length","find","create","options","uid","update","upsert","dismiss","getCount","getPlacements","placements","map","Array","from","Set","remove","dismissByPlacement","forEach","promise","shared","arguments","undefined","then","response","successOptions","catch","errorOptions","finally","pause","resume","getGroupProps","label","hotkeyLabel","hotkey","join","align","element","group","attrs","tabIndex","role","style","onMouseMove","onMouseLeave","onFocus","event","target","relatedTarget","onBlur","isFocusWithin","currentTarget","fn","contexts","createMachine","createMachine2","ref","trackDismissableBranch","addDomEvent","compact","compact2","guards","queryAll","raf","warn","not","and","or","createToastMachine","restProps","computedDuration","remaining","createdAt","Date","now","initial","on","UPDATE","guard","actions","MEASURE","entry","activities","states","tags","after","RESUME","DISMISS","VISIBLE_DURATION","PAUSE","dismissing","REMOVE_DELAY","unmounted","trackHeight","ctx2","_evt","_ref","self","cleanup","rootEl","ghosts","syncHeight","originalHeight","newHeight","getBoundingClientRect","sendParent","win","getWin","observer","MutationObserver","observe","childList","subtree","characterData","disconnect","isChangingToLoading","_","evt","isLoadingType","hasTypeChanged","hasDurationChanged","delays","measureHeight","_ref2","setRemainingDuration","setCreatedAt","notifyParentToRemove","_ref3","invokeOnDismiss","onStatusChange","status","invokeOnUnmount","invokeOnVisible","setContext","duration2","type2","computedDuration2","groupMachine","userContext","max","pauseOnPageIdle","lastFocusedEl","computed","watch","exit","PAUSE_TOAST","PAUSE_ALL","RESUME_TOAST","RESUME_ALL","ADD_TOAST","UPDATE_TOAST","DISMISS_TOAST","DISMISS_ALL","REMOVE_TOAST","REMOVE_ALL","UPDATE_HEIGHT","stack","isWithinRange","isOverlapping","trackHotKeyPress","_ref4","handleKeyDown","isHotkeyPressed","every","key","code","document","capture","trackDocumentVisibility","_ref5","doc","getDoc","visibilityState","setDismissableBranch","currentToasts","hasToasts","_cleanup","groupEl","defer","clearDismissableBranch","focusRegionEl","queueMicrotask","focus","expandToasts","each","collapseToasts","collapsedIfEmpty","_ref6","pauseToast","_ref7","sendChild","pauseToasts","resumeToast","_ref8","resumeToasts","measureToasts","createToast","_ref9","getRootNode","matches","actor","spawn","updateToast","_ref10","dismissToast","_ref11","dismissToasts","removeToast","_ref12","stopChild","removeToasts","_ref13","syncHeights","existing","syncToastIndex","syncToastOffset","heightIndex","Math","findIndex","toastsHeightBefore","reduce","prev","curr","reducerIndex","setLastFocusedEl","restoreLastFocusedEl","preventScroll","clearLastFocusedEl","dataAttr","connect","hasTag","paused","title","description","getRootProps","root","onKeyDown","defaultPrevented","preventDefault","getGhostBeforeProps","getGhostAfterProps","getTitleProps","getDescriptionProps","getActionTriggerProps","button","actionTrigger","onClick","getCloseTriggerProps","closeTrigger","machine"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast-group.connect.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.anatomy.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.dom.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast-group.machine.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.machine.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.connect.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/index.ts"],"sourcesContent":["import { isMachine, subscribe } from \"@zag-js/core\"\nimport { contains } from \"@zag-js/dom-query\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { runIfFn, uuid } from \"@zag-js/utils\"\nimport { parts } from \"./toast.anatomy\"\nimport { dom } from \"./toast.dom\"\nimport type { GroupMachineApi, GroupSend, GroupService, GroupState, Options, Placement } from \"./toast.types\"\nimport { getGroupPlacementStyle, getToastsByPlacement } from \"./toast.utils\"\n\nexport function groupConnect<T extends PropTypes, O = any>(\n  serviceOrState: GroupState<O> | GroupService<O>,\n  send: GroupSend,\n  normalize: NormalizeProps<T>,\n): GroupMachineApi<T, O> {\n  //\n\n  function getState(): GroupState<O> {\n    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState\n    return result as GroupState<O>\n  }\n\n  function getToastsByPlacementImpl(placement: Placement) {\n    return getToastsByPlacement(getState().context.toasts, placement)\n  }\n\n  function isVisible(id: string) {\n    const toasts = getState().context.toasts\n    if (!toasts.length) return false\n    return !!toasts.find((toast) => toast.id == id)\n  }\n\n  function create(options: Options<O>) {\n    const uid = `toast:${uuid()}`\n    const id = options.id ? options.id : uid\n\n    if (isVisible(id)) return id\n    send({ type: \"ADD_TOAST\", toast: { ...options, id } })\n\n    return id\n  }\n\n  function update(id: string, options: Options<O>) {\n    if (!isVisible(id)) return id\n    send({ type: \"UPDATE_TOAST\", id, toast: options })\n    return id\n  }\n\n  function upsert(options: Options<O>) {\n    const { id } = options\n    const visible = id ? isVisible(id) : false\n    if (visible && id != null) {\n      return update(id, options)\n    } else {\n      return create(options)\n    }\n  }\n\n  function dismiss(id?: string) {\n    if (id == null) {\n      send(\"DISMISS_ALL\")\n    } else if (isVisible(id)) {\n      send({ type: \"DISMISS_TOAST\", id })\n    }\n  }\n\n  return {\n    getCount() {\n      return getState().context.count\n    },\n    getPlacements() {\n      const toasts = getState().context.toasts\n      const placements = toasts.map((toast) => toast.state.context.placement!)\n      return Array.from(new Set(placements))\n    },\n    getToastsByPlacement: getToastsByPlacementImpl,\n    isVisible,\n    create,\n    update,\n    upsert,\n    dismiss,\n\n    remove(id) {\n      if (id == null) {\n        send(\"REMOVE_ALL\")\n      } else if (isVisible(id)) {\n        send({ type: \"REMOVE_TOAST\", id })\n      }\n    },\n\n    dismissByPlacement(placement) {\n      const toasts = getToastsByPlacementImpl(placement)\n      toasts.forEach((toast) => dismiss(toast.id))\n    },\n    loading(options) {\n      return upsert({ ...options, type: \"loading\" })\n    },\n    success(options) {\n      return upsert({ ...options, type: \"success\" })\n    },\n    error(options) {\n      return upsert({ ...options, type: \"error\" })\n    },\n\n    promise(promise, options, shared = {}) {\n      const id = upsert({ ...shared, ...options.loading, type: \"loading\" })\n\n      runIfFn(promise)\n        .then((response) => {\n          const successOptions = runIfFn(options.success, response)\n          upsert({ ...shared, ...successOptions, id, type: \"success\" })\n        })\n        .catch((error) => {\n          const errorOptions = runIfFn(options.error, error)\n          upsert({ ...shared, ...errorOptions, id, type: \"error\" })\n        })\n        .finally(() => {\n          options.finally?.()\n        })\n\n      return id\n    },\n\n    pause(id) {\n      if (id == null) {\n        send(\"PAUSE_ALL\")\n      } else if (isVisible(id)) {\n        send({ type: \"PAUSE_TOAST\", id })\n      }\n    },\n\n    resume(id) {\n      if (id == null) {\n        send(\"RESUME_ALL\")\n      } else if (isVisible(id)) {\n        send({ type: \"RESUME_TOAST\", id })\n      }\n    },\n\n    getGroupProps(options) {\n      const { placement, label = \"Notifications\" } = options\n      const state = getState()\n      const hotkeyLabel = state.context.hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\")\n      const [side, align = \"center\"] = placement.split(\"-\")\n\n      return normalize.element({\n        ...parts.group.attrs,\n        dir: state.context.dir,\n        tabIndex: -1,\n        \"aria-label\": `${placement} ${label} ${hotkeyLabel}`,\n        id: dom.getRegionId(placement),\n        \"data-placement\": placement,\n        \"data-side\": side,\n        \"data-align\": align,\n        \"aria-live\": \"polite\",\n        role: \"region\",\n        style: getGroupPlacementStyle(state.context, placement),\n        onMouseMove() {\n          send({ type: \"REGION.POINTER_ENTER\", placement })\n        },\n        onMouseLeave() {\n          send({ type: \"REGION.POINTER_LEAVE\", placement })\n        },\n        onFocus(event) {\n          send({ type: \"REGION.FOCUS\", target: event.relatedTarget })\n        },\n        onBlur(event) {\n          if (state.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {\n            send({ type: \"REGION.BLUR\" })\n          }\n        },\n      })\n    },\n\n    subscribe(fn) {\n      const state = getState()\n      return subscribe(state.context.toasts, () => {\n        const toasts = getToastsByPlacementImpl(state.context.placement)\n        const contexts = toasts.map((toast) => toast.getState().context)\n        fn(contexts)\n      })\n    },\n  }\n}\n","import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"toast\").parts(\n  \"group\",\n  \"root\",\n  \"title\",\n  \"description\",\n  \"actionTrigger\",\n  \"closeTrigger\",\n)\n\nexport const parts = anatomy.build()\n","import { createScope } from \"@zag-js/dom-query\"\nimport type { MachineContext as Ctx, Placement, GroupMachineContext as GroupCtx } from \"./toast.types\"\n\nexport const dom = createScope({\n  getRegionId: (placement: Placement) => `toast-group:${placement}`,\n  getRegionEl: (ctx: GroupCtx, placement: Placement) => dom.getById(ctx, `toast-group:${placement}`),\n\n  getRootId: (ctx: Ctx) => `toast:${ctx.id}`,\n  getRootEl: (ctx: Ctx) => dom.getById(ctx, dom.getRootId(ctx)),\n  getTitleId: (ctx: Ctx) => `toast:${ctx.id}:title`,\n  getDescriptionId: (ctx: Ctx) => `toast:${ctx.id}:description`,\n  getCloseTriggerId: (ctx: Ctx) => `toast${ctx.id}:close`,\n})\n","import { MAX_Z_INDEX } from \"@zag-js/dom-query\"\nimport type { Style } from \"@zag-js/types\"\nimport type { GroupMachineContext, MachineContext, Placement, Service, Type } from \"./toast.types\"\n\nexport function getToastsByPlacement<T>(toasts: Service<T>[], placement: Placement) {\n  return toasts.filter((toast) => toast.state.context.placement === placement)\n}\n\nexport const defaultTimeouts: Record<Type, number> = {\n  info: 5000,\n  error: 5000,\n  success: 2000,\n  loading: Infinity,\n  DEFAULT: 5000,\n}\n\nexport function getToastDuration(duration: number | undefined, type: NonNullable<MachineContext[\"type\"]>) {\n  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT\n}\n\nexport function getGroupPlacementStyle<T>(ctx: GroupMachineContext<T>, placement: Placement): Style {\n  const offset = ctx.offsets\n  const computedOffset =\n    typeof offset === \"string\" ? { left: offset, right: offset, bottom: offset, top: offset } : offset\n\n  const rtl = ctx.dir === \"rtl\"\n  const computedPlacement = placement\n    .replace(\"-start\", rtl ? \"-right\" : \"-left\")\n    .replace(\"-end\", rtl ? \"-left\" : \"-right\")\n\n  const isRighty = computedPlacement.includes(\"right\")\n  const isLefty = computedPlacement.includes(\"left\")\n\n  const styles: Style = {\n    position: \"fixed\",\n    pointerEvents: ctx.count > 0 ? undefined : \"none\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"--gap\": `${ctx.gap}px`,\n    \"--first-height\": `${ctx.heights[0]?.height || 0}px`,\n    zIndex: MAX_Z_INDEX,\n  }\n\n  let alignItems: Style[\"alignItems\"] = \"center\"\n  if (isRighty) alignItems = \"flex-end\"\n  if (isLefty) alignItems = \"flex-start\"\n\n  styles.alignItems = alignItems\n\n  if (computedPlacement.includes(\"top\")) {\n    const offset = computedOffset.top\n    styles.top = `max(env(safe-area-inset-top, 0px), ${offset})`\n  }\n\n  if (computedPlacement.includes(\"bottom\")) {\n    const offset = computedOffset.bottom\n    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset})`\n  }\n\n  if (!computedPlacement.includes(\"left\")) {\n    const offset = computedOffset.right\n    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset})`\n  }\n\n  if (!computedPlacement.includes(\"right\")) {\n    const offset = computedOffset.left\n    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset})`\n  }\n\n  return styles\n}\n\nexport function getPlacementStyle<T>(ctx: MachineContext<T>, visible: boolean): Style {\n  const [side] = ctx.placement!.split(\"-\")\n  const sibling = !ctx.frontmost\n  const overlap = !ctx.stacked\n\n  const styles: Style = {\n    position: \"absolute\",\n    pointerEvents: \"auto\",\n    \"--opacity\": \"0\",\n    \"--remove-delay\": `${ctx.removeDelay}ms`,\n    \"--duration\": `${ctx.type === \"loading\" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,\n    \"--initial-height\": `${ctx.height}px`,\n    \"--offset\": `${ctx.offset}px`,\n    \"--index\": ctx.index,\n    \"--z-index\": ctx.zIndex,\n    \"--lift-amount\": \"calc(var(--lift) * var(--gap))\",\n    \"--y\": \"100%\",\n    \"--x\": \"0\",\n  }\n\n  const assign = (overrides: Style) => Object.assign(styles, overrides)\n\n  if (side === \"top\") {\n    //\n    assign({\n      top: \"0\",\n      \"--sign\": \"-1\",\n      \"--y\": \"-100%\",\n      \"--lift\": \"1\",\n    })\n    //\n  } else if (side === \"bottom\") {\n    //\n    assign({\n      bottom: \"0\",\n      \"--sign\": \"1\",\n      \"--y\": \"100%\",\n      \"--lift\": \"-1\",\n    })\n  }\n\n  if (ctx.mounted) {\n    assign({\n      \"--y\": \"0\",\n      \"--opacity\": \"1\",\n    })\n\n    if (ctx.stacked) {\n      assign({\n        \"--y\": \"calc(var(--lift) * var(--offset))\",\n        \"--height\": \"var(--initial-height)\",\n      })\n    }\n  }\n\n  if (!visible) {\n    assign({\n      \"--opacity\": \"0\",\n      pointerEvents: \"none\",\n    })\n  }\n\n  if (sibling && overlap) {\n    assign({\n      \"--base-scale\": \"var(--index) * 0.05 + 1\",\n      \"--y\": \"calc(var(--lift-amount) * var(--index))\",\n      \"--scale\": \"calc(-1 * var(--base-scale))\",\n      \"--height\": \"var(--first-height)\",\n    })\n\n    if (!visible) {\n      assign({\n        \"--y\": \"calc(var(--sign) * 40%)\",\n      })\n    }\n  }\n\n  if (sibling && ctx.stacked && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * var(--offset) + var(--lift) * -100%)\",\n    })\n  }\n\n  if (ctx.frontmost && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * -100%)\",\n    })\n  }\n\n  return styles\n}\n\nexport function getGhostBeforeStyle<T>(ctx: MachineContext<T>, visible: boolean): Style {\n  const styles: Style = {\n    position: \"absolute\",\n    inset: \"0\",\n    scale: \"1 2\",\n    pointerEvents: visible ? \"none\" : \"auto\",\n  }\n\n  const assign = (overrides: Style) => Object.assign(styles, overrides)\n\n  if (ctx.frontmost && !visible) {\n    assign({\n      height: \"calc(var(--initial-height) + 80%)\",\n    })\n  }\n\n  return styles\n}\n\nexport function getGhostAfterStyle<T>(_ctx: MachineContext<T>, _visible: boolean): Style {\n  return {\n    position: \"absolute\",\n    left: \"0\",\n    height: \"calc(var(--gap) + 2px)\",\n    bottom: \"100%\",\n    width: \"100%\",\n  }\n}\n","import { createMachine, ref } from \"@zag-js/core\"\nimport { trackDismissableBranch } from \"@zag-js/dismissable\"\nimport { addDomEvent } from \"@zag-js/dom-event\"\nimport { compact } from \"@zag-js/utils\"\nimport { dom } from \"./toast.dom\"\nimport { createToastMachine } from \"./toast.machine\"\nimport type {\n  GroupMachineContext,\n  GroupMachineState,\n  MachineContext,\n  Service,\n  UserDefinedGroupContext,\n} from \"./toast.types\"\nimport { getToastsByPlacement } from \"./toast.utils\"\n\nexport function groupMachine<T = any>(userContext: UserDefinedGroupContext) {\n  const ctx = compact(userContext)\n  return createMachine<GroupMachineContext<T>, GroupMachineState>(\n    {\n      id: \"toaster\",\n      initial: ctx.overlap ? \"overlap\" : \"stack\",\n      context: {\n        dir: \"ltr\",\n        max: Number.MAX_SAFE_INTEGER,\n        gap: 16,\n        pauseOnPageIdle: false,\n        hotkey: [\"altKey\", \"KeyT\"],\n        offsets: \"1rem\",\n        placement: \"bottom\",\n        removeDelay: 200,\n        ...ctx,\n        toasts: [],\n        lastFocusedEl: null,\n        isFocusWithin: false,\n        heights: [],\n      },\n\n      computed: {\n        count: (ctx) => ctx.toasts.length,\n      },\n\n      activities: [\"trackDocumentVisibility\", \"trackHotKeyPress\"],\n\n      watch: {\n        toasts: [\"collapsedIfEmpty\", \"setDismissableBranch\"],\n      },\n\n      exit: [\"removeToasts\", \"clearDismissableBranch\", \"clearLastFocusedEl\"],\n\n      on: {\n        PAUSE_TOAST: {\n          actions: [\"pauseToast\"],\n        },\n        PAUSE_ALL: {\n          actions: [\"pauseToasts\"],\n        },\n        RESUME_TOAST: {\n          actions: [\"resumeToast\"],\n        },\n        RESUME_ALL: {\n          actions: [\"resumeToasts\"],\n        },\n        ADD_TOAST: {\n          guard: \"isWithinRange\",\n          actions: [\"createToast\", \"syncToastIndex\"],\n        },\n        UPDATE_TOAST: {\n          actions: [\"updateToast\"],\n        },\n        DISMISS_TOAST: {\n          actions: [\"dismissToast\"],\n        },\n        DISMISS_ALL: {\n          actions: [\"dismissToasts\"],\n        },\n        REMOVE_TOAST: {\n          actions: [\"removeToast\", \"syncToastIndex\", \"syncToastOffset\"],\n        },\n        REMOVE_ALL: {\n          actions: [\"removeToasts\"],\n        },\n        UPDATE_HEIGHT: {\n          actions: [\"syncHeights\", \"syncToastOffset\"],\n        },\n        \"DOC.HOTKEY\": {\n          actions: [\"focusRegionEl\"],\n        },\n        \"REGION.BLUR\": [\n          {\n            guard: \"isOverlapping\",\n            target: \"overlap\",\n            actions: [\"resumeToasts\", \"restoreLastFocusedEl\"],\n          },\n          {\n            actions: [\"resumeToasts\", \"restoreLastFocusedEl\"],\n          },\n        ],\n      },\n\n      states: {\n        stack: {\n          entry: [\"expandToasts\"],\n          on: {\n            \"REGION.POINTER_LEAVE\": [\n              {\n                guard: \"isOverlapping\",\n                target: \"overlap\",\n                actions: [\"resumeToasts\"],\n              },\n              {\n                actions: [\"resumeToasts\"],\n              },\n            ],\n            \"REGION.OVERLAP\": {\n              target: \"overlap\",\n            },\n            \"REGION.FOCUS\": {\n              actions: [\"setLastFocusedEl\", \"pauseToasts\"],\n            },\n            \"REGION.POINTER_ENTER\": {\n              actions: [\"pauseToasts\"],\n            },\n          },\n        },\n        overlap: {\n          entry: [\"collapseToasts\"],\n          on: {\n            \"REGION.STACK\": {\n              target: \"stack\",\n            },\n            \"REGION.POINTER_ENTER\": {\n              target: \"stack\",\n              actions: [\"pauseToasts\"],\n            },\n            \"REGION.FOCUS\": {\n              target: \"stack\",\n              actions: [\"setLastFocusedEl\", \"pauseToasts\"],\n            },\n          },\n        },\n      },\n    },\n    {\n      guards: {\n        isWithinRange: (ctx) => ctx.toasts.length < ctx.max,\n        isOverlapping: (ctx) => !!ctx.overlap,\n      },\n      activities: {\n        trackHotKeyPress(ctx, _evt, { send }) {\n          const handleKeyDown = (event: KeyboardEvent) => {\n            const isHotkeyPressed = ctx.hotkey.every((key) => (event as any)[key] || event.code === key)\n            if (!isHotkeyPressed) return\n            send({ type: \"DOC.HOTKEY\" })\n          }\n          return addDomEvent(document, \"keydown\", handleKeyDown, { capture: true })\n        },\n        trackDocumentVisibility(ctx, _evt, { send }) {\n          if (!ctx.pauseOnPageIdle) return\n          const doc = dom.getDoc(ctx)\n          return addDomEvent(doc, \"visibilitychange\", () => {\n            send(doc.visibilityState === \"hidden\" ? \"PAUSE_ALL\" : \"RESUME_ALL\")\n          })\n        },\n      },\n      actions: {\n        setDismissableBranch(ctx) {\n          const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement)\n          const hasToasts = currentToasts.length > 0\n\n          if (!hasToasts) {\n            ctx._cleanup?.()\n            return\n          }\n\n          if (hasToasts && ctx._cleanup) {\n            return\n          }\n\n          //  mark toast as a dismissable branch\n          //  so that interacting with them will not close dismissable layers\n          const groupEl = () => dom.getRegionEl(ctx, ctx.placement)\n          ctx._cleanup = trackDismissableBranch(groupEl, { defer: true })\n        },\n        clearDismissableBranch(ctx) {\n          ctx._cleanup?.()\n        },\n        focusRegionEl(ctx) {\n          queueMicrotask(() => {\n            dom.getRegionEl(ctx, ctx.placement)?.focus()\n          })\n        },\n        expandToasts(ctx) {\n          each(ctx, (toast) => {\n            toast.state.context.stacked = true\n          })\n        },\n        collapseToasts(ctx) {\n          each(ctx, (toast) => {\n            toast.state.context.stacked = false\n          })\n        },\n        collapsedIfEmpty(ctx, _evt, { send }) {\n          if (!ctx.overlap || ctx.toasts.length > 1) return\n          send(\"REGION.OVERLAP\")\n        },\n        pauseToast(_ctx, evt, { self }) {\n          self.sendChild(\"PAUSE\", evt.id)\n        },\n        pauseToasts(ctx) {\n          ctx.toasts.forEach((toast) => toast.send(\"PAUSE\"))\n        },\n        resumeToast(_ctx, evt, { self }) {\n          self.sendChild(\"RESUME\", evt.id)\n        },\n        resumeToasts(ctx) {\n          ctx.toasts.forEach((toast) => toast.send(\"RESUME\"))\n        },\n        measureToasts(ctx) {\n          ctx.toasts.forEach((toast) => toast.send(\"MEASURE\"))\n        },\n        createToast(ctx, evt, { self, getState }) {\n          const options: MachineContext<T> = {\n            placement: ctx.placement,\n            duration: ctx.duration,\n            removeDelay: ctx.removeDelay,\n            ...evt.toast,\n            dir: ctx.dir,\n            getRootNode: ctx.getRootNode,\n            stacked: getState().matches(\"stack\"),\n          }\n\n          const toast = createToastMachine(options)\n\n          const actor = self.spawn(toast)\n          ctx.toasts = [actor, ...ctx.toasts]\n        },\n        updateToast(_ctx, evt, { self }) {\n          self.sendChild({ type: \"UPDATE\", toast: evt.toast }, evt.id)\n        },\n        dismissToast(_ctx, evt, { self }) {\n          self.sendChild(\"DISMISS\", evt.id)\n        },\n        dismissToasts(ctx) {\n          ctx.toasts.forEach((toast) => toast.send(\"DISMISS\"))\n        },\n        removeToast(ctx, evt, { self }) {\n          self.stopChild(evt.id)\n          ctx.toasts = ctx.toasts.filter((toast) => toast.id !== evt.id)\n          ctx.heights = ctx.heights.filter((height) => height.id !== evt.id)\n        },\n        removeToasts(ctx, _evt, { self }) {\n          ctx.toasts.forEach((toast) => self.stopChild(toast.id))\n          ctx.toasts = []\n          ctx.heights = []\n        },\n        syncHeights(ctx, evt) {\n          const existing = ctx.heights.find((height) => height.id === evt.id)\n          if (existing) {\n            existing.height = evt.height\n            existing.placement = evt.placement\n          } else {\n            const newHeight = { id: evt.id, height: evt.height, placement: evt.placement }\n            ctx.heights = [newHeight, ...ctx.heights]\n          }\n        },\n        syncToastIndex(ctx) {\n          each(ctx, (toast, index, toasts) => {\n            // Note: This is an intentional side effect\n            // consider writing directly to the DOM (root element)\n            toast.state.context.index = index\n            toast.state.context.frontmost = index === 0\n            toast.state.context.zIndex = toasts.length - index\n          })\n        },\n        syncToastOffset(ctx, evt) {\n          const placement = evt.placement ?? ctx.placement\n\n          // Notify each toast of it's index\n          each({ ...ctx, placement }, (toast) => {\n            const heightIndex = Math.max(\n              ctx.heights.findIndex((height) => height.id === toast.id),\n              0,\n            )\n\n            // calculate offset until toast\n            const toastsHeightBefore = ctx.heights.reduce((prev, curr, reducerIndex) => {\n              if (reducerIndex >= heightIndex) return prev\n              return prev + curr.height\n            }, 0)\n\n            // Note: This is an intentional side effect\n            // consider writing directly to the DOM (root element)\n            toast.state.context.offset = heightIndex * ctx.gap + toastsHeightBefore\n          })\n        },\n        setLastFocusedEl(ctx, evt) {\n          if (ctx.isFocusWithin || !evt.target) return\n          ctx.isFocusWithin = true\n          ctx.lastFocusedEl = ref(evt.target)\n        },\n        restoreLastFocusedEl(ctx) {\n          ctx.isFocusWithin = false\n          if (!ctx.lastFocusedEl) return\n          ctx.lastFocusedEl.focus({ preventScroll: true })\n          ctx.lastFocusedEl = null\n        },\n        clearLastFocusedEl(ctx) {\n          if (!ctx.lastFocusedEl) return\n          ctx.lastFocusedEl.focus({ preventScroll: true })\n          ctx.lastFocusedEl = null\n          ctx.isFocusWithin = false\n        },\n      },\n    },\n  )\n}\n\nfunction each(ctx: GroupMachineContext, fn: (toast: Service<any>, index: number, arr: Service<any>[]) => void) {\n  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement)\n  currentToasts.forEach(fn)\n}\n","import { createMachine, guards } from \"@zag-js/core\"\nimport { queryAll, raf } from \"@zag-js/dom-query\"\nimport { compact, warn } from \"@zag-js/utils\"\nimport { dom } from \"./toast.dom\"\nimport type { MachineContext, MachineState, Options } from \"./toast.types\"\nimport { getToastDuration } from \"./toast.utils\"\n\nconst { not, and, or } = guards\n\nexport function createToastMachine<T>(options: Options<T>) {\n  const { type = \"info\", duration, id = \"1\", placement = \"bottom\", removeDelay = 200, ...restProps } = options\n  const ctx = compact(restProps)\n\n  const computedDuration = getToastDuration(duration, type)\n\n  return createMachine<MachineContext<T>, MachineState>(\n    {\n      id,\n      context: {\n        id,\n        type,\n        remaining: computedDuration,\n        duration: computedDuration,\n        removeDelay,\n        createdAt: Date.now(),\n        placement,\n        ...ctx,\n        height: 0,\n        offset: 0,\n        frontmost: false,\n        mounted: false,\n        index: -1,\n        zIndex: 0,\n      },\n\n      initial: type === \"loading\" ? \"visible:persist\" : \"visible\",\n\n      on: {\n        UPDATE: [\n          {\n            guard: and(\"hasTypeChanged\", \"isChangingToLoading\"),\n            target: \"visible:persist\",\n            actions: [\"setContext\"],\n          },\n          {\n            guard: or(\"hasDurationChanged\", \"hasTypeChanged\"),\n            target: \"visible:updating\",\n            actions: [\"setContext\"],\n          },\n          {\n            actions: [\"setContext\"],\n          },\n        ],\n        MEASURE: {\n          actions: [\"measureHeight\"],\n        },\n      },\n\n      entry: [\"invokeOnVisible\"],\n\n      activities: [\"trackHeight\"],\n\n      states: {\n        \"visible:updating\": {\n          tags: [\"visible\", \"updating\"],\n          after: {\n            0: \"visible\",\n          },\n        },\n\n        \"visible:persist\": {\n          tags: [\"visible\", \"paused\"],\n          on: {\n            RESUME: {\n              guard: not(\"isLoadingType\"),\n              target: \"visible\",\n              actions: [\"setCreatedAt\"],\n            },\n            DISMISS: \"dismissing\",\n          },\n        },\n\n        visible: {\n          tags: [\"visible\"],\n          after: {\n            VISIBLE_DURATION: \"dismissing\",\n          },\n          on: {\n            DISMISS: \"dismissing\",\n            PAUSE: {\n              target: \"visible:persist\",\n              actions: \"setRemainingDuration\",\n            },\n          },\n        },\n\n        dismissing: {\n          entry: \"invokeOnDismiss\",\n          after: {\n            REMOVE_DELAY: {\n              target: \"unmounted\",\n              actions: \"notifyParentToRemove\",\n            },\n          },\n        },\n\n        unmounted: {\n          entry: \"invokeOnUnmount\",\n          type: \"final\",\n        },\n      },\n    },\n    {\n      activities: {\n        trackHeight(ctx, _evt, { self }) {\n          let cleanup: VoidFunction\n          raf(() => {\n            const rootEl = dom.getRootEl(ctx)\n            if (!rootEl) return\n            ctx.mounted = true\n\n            const ghosts = queryAll(rootEl, \"[data-ghost]\")\n\n            warn(\n              ghosts.length !== 2,\n              \"[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements\",\n            )\n\n            const syncHeight = () => {\n              const originalHeight = rootEl.style.height\n              rootEl.style.height = \"auto\"\n              const newHeight = rootEl.getBoundingClientRect().height\n              rootEl.style.height = originalHeight\n\n              ctx.height = newHeight\n              self.sendParent({ type: \"UPDATE_HEIGHT\", id: self.id, height: newHeight, placement: ctx.placement })\n            }\n\n            syncHeight()\n\n            const win = dom.getWin(ctx)\n\n            const observer = new win.MutationObserver(syncHeight)\n            observer.observe(rootEl, { childList: true, subtree: true, characterData: true })\n\n            cleanup = () => observer.disconnect()\n          })\n\n          return () => cleanup?.()\n        },\n      },\n\n      guards: {\n        isChangingToLoading: (_, evt) => evt.toast?.type === \"loading\",\n        isLoadingType: (ctx) => ctx.type === \"loading\",\n        hasTypeChanged: (ctx, evt) => evt.toast?.type != null && evt.toast.type !== ctx.type,\n        hasDurationChanged: (ctx, evt) => evt.toast?.duration != null && evt.toast.duration !== ctx.duration,\n      },\n\n      delays: {\n        VISIBLE_DURATION: (ctx) => ctx.remaining,\n        REMOVE_DELAY: (ctx) => ctx.removeDelay,\n      },\n\n      actions: {\n        measureHeight(ctx, _evt, { self }) {\n          raf(() => {\n            const rootEl = dom.getRootEl(ctx)\n            if (!rootEl) return\n\n            ctx.mounted = true\n\n            const originalHeight = rootEl.style.height\n            rootEl.style.height = \"auto\"\n\n            const newHeight = rootEl.getBoundingClientRect().height\n            rootEl.style.height = originalHeight\n            ctx.height = newHeight\n\n            self.sendParent({ type: \"UPDATE_HEIGHT\", id: self.id, height: newHeight, placement: ctx.placement })\n          })\n        },\n        setRemainingDuration(ctx) {\n          ctx.remaining -= Date.now() - ctx.createdAt\n        },\n        setCreatedAt(ctx) {\n          ctx.createdAt = Date.now()\n        },\n        notifyParentToRemove(_ctx, _evt, { self }) {\n          self.sendParent({ type: \"REMOVE_TOAST\", id: self.id })\n        },\n        invokeOnDismiss(ctx) {\n          ctx.onStatusChange?.({ status: \"dismissing\" })\n        },\n        invokeOnUnmount(ctx) {\n          ctx.onStatusChange?.({ status: \"unmounted\" })\n        },\n        invokeOnVisible(ctx) {\n          ctx.onStatusChange?.({ status: \"visible\" })\n        },\n        setContext(ctx, evt) {\n          const duration = evt.toast?.duration\n          const type = evt.toast?.type ?? ctx.type\n\n          const computedDuration = getToastDuration(duration, type)\n\n          Object.assign(ctx, {\n            ...evt.toast,\n            duration: computedDuration,\n            remaining: computedDuration,\n          })\n        },\n      },\n    },\n  )\n}\n","import { dataAttr } from \"@zag-js/dom-query\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./toast.anatomy\"\nimport { dom } from \"./toast.dom\"\nimport type { MachineApi, Send, State } from \"./toast.types\"\nimport { getGhostAfterStyle, getGhostBeforeStyle, getPlacementStyle } from \"./toast.utils\"\n\nexport function connect<T extends PropTypes, O>(\n  state: State<O>,\n  send: Send,\n  normalize: NormalizeProps<T>,\n): MachineApi<T, O> {\n  const visible = state.hasTag(\"visible\")\n  const paused = state.hasTag(\"paused\")\n\n  const placement = state.context.placement!\n  const type = state.context.type!\n\n  const [side, align = \"center\"] = placement.split(\"-\")\n\n  return {\n    type: type,\n    title: state.context.title,\n    description: state.context.description,\n    placement,\n    visible: visible,\n    paused: paused,\n\n    pause() {\n      send(\"PAUSE\")\n    },\n\n    resume() {\n      send(\"RESUME\")\n    },\n\n    dismiss() {\n      send(\"DISMISS\")\n    },\n\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-state\": visible ? \"open\" : \"closed\",\n        \"data-type\": type,\n        \"data-placement\": placement,\n        \"data-align\": align,\n        \"data-side\": side,\n        \"data-mounted\": dataAttr(state.context.mounted),\n        \"data-paused\": dataAttr(paused),\n\n        \"data-first\": dataAttr(state.context.frontmost),\n        \"data-sibling\": dataAttr(!state.context.frontmost),\n        \"data-stack\": dataAttr(state.context.stacked),\n        \"data-overlap\": dataAttr(!state.context.stacked),\n\n        role: \"status\",\n        \"aria-atomic\": \"true\",\n        \"aria-describedby\": state.context.description ? dom.getDescriptionId(state.context) : undefined,\n        \"aria-labelledby\": state.context.title ? dom.getTitleId(state.context) : undefined,\n        tabIndex: 0,\n        style: getPlacementStyle(state.context, visible),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return\n          if (event.key == \"Escape\") {\n            send(\"DISMISS\")\n            event.preventDefault()\n          }\n        },\n      })\n    },\n\n    /* Leave a ghost div to avoid setting hover to false when transitioning out */\n    getGhostBeforeProps() {\n      return normalize.element({\n        \"data-ghost\": \"before\",\n        style: getGhostBeforeStyle(state.context, visible),\n      })\n    },\n\n    /* Needed to avoid setting hover to false when in between toasts */\n    getGhostAfterProps() {\n      return normalize.element({\n        \"data-ghost\": \"after\",\n        style: getGhostAfterStyle(state.context, visible),\n      })\n    },\n\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: dom.getTitleId(state.context),\n      })\n    },\n\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: dom.getDescriptionId(state.context),\n      })\n    },\n\n    getActionTriggerProps() {\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return\n          send(\"DISMISS\")\n        },\n      })\n    },\n\n    getCloseTriggerProps() {\n      return normalize.button({\n        id: dom.getCloseTriggerId(state.context),\n        ...parts.closeTrigger.attrs,\n        type: \"button\",\n        \"aria-label\": \"Dismiss notification\",\n        onClick(event) {\n          if (event.defaultPrevented) return\n          send(\"DISMISS\")\n        },\n      })\n    },\n  }\n}\n","import { groupConnect } from \"./toast-group.connect\"\nimport { groupMachine } from \"./toast-group.machine\"\nimport { createToastMachine as createMachine } from \"./toast.machine\"\n\nexport { anatomy } from \"./toast.anatomy\"\nexport { connect } from \"./toast.connect\"\nexport type {\n  MachineApi as Api,\n  GenericOptions,\n  GroupMachineApi as GroupApi,\n  GroupMachineContext,\n  GroupProps,\n  GroupService,\n  GroupState,\n  MachineContext,\n  Placement,\n  PromiseOptions,\n  Service,\n  StatusChangeDetails,\n  Options,\n  Status,\n  Type,\n} from \"./toast.types\"\nexport { createMachine }\n\nexport const group = {\n  connect: groupConnect,\n  machine: groupMachine,\n}\n"],"mappings":";AAAA,SAASA,SAAA,EAAWC,SAAA,QAAiB;AACrC,SAASC,QAAA,QAAgB;AAEzB,SAASC,OAAA,EAASC,IAAA,QAAY;;;ACH9B,SAASC,aAAA,QAAqB;AAEvB,IAAMC,OAAA,GAAUD,aAAA,CAAc,OAAO,EAAEE,KAAA,CAC5C,SACA,QACA,SACA,eACA,iBACA,cACF;AAEO,IAAMA,KAAA,GAAQD,OAAA,CAAQE,KAAA,CAAM;;;ACXnC,SAASC,WAAA,QAAmB;AAGrB,IAAMC,GAAA,GAAMD,WAAA,CAAY;EAC7BE,WAAA,EAAcC,SAAA,IAAyB,eAAeA,SAAS;EAC/DC,WAAA,EAAaA,CAACC,GAAA,EAAeF,SAAA,KAAyBF,GAAA,CAAIK,OAAA,CAAQD,GAAA,EAAK,eAAeF,SAAS,EAAE;EAEjGI,SAAA,EAAYF,GAAA,IAAa,SAASA,GAAA,CAAIG,EAAE;EACxCC,SAAA,EAAYJ,GAAA,IAAaJ,GAAA,CAAIK,OAAA,CAAQD,GAAA,EAAKJ,GAAA,CAAIM,SAAA,CAAUF,GAAG,CAAC;EAC5DK,UAAA,EAAaL,GAAA,IAAa,SAASA,GAAA,CAAIG,EAAE;EACzCG,gBAAA,EAAmBN,GAAA,IAAa,SAASA,GAAA,CAAIG,EAAE;EAC/CI,iBAAA,EAAoBP,GAAA,IAAa,QAAQA,GAAA,CAAIG,EAAE;AACjD,CAAC;;;ACZD,SAASK,WAAA,QAAmB;AAIrB,SAASC,qBAAwBC,MAAA,EAAsBZ,SAAA,EAAsB;EAClF,OAAOY,MAAA,CAAOC,MAAA,CAAQC,KAAA,IAAUA,KAAA,CAAMC,KAAA,CAAMC,OAAA,CAAQhB,SAAA,KAAcA,SAAS;AAC7E;AAEO,IAAMiB,eAAA,GAAwC;EACnDC,IAAA,EAAM;EACNC,KAAA,EAAO;EACPC,OAAA,EAAS;EACTC,OAAA,EAASC,QAAA;EACTC,OAAA,EAAS;AACX;AAEO,SAASC,iBAAiBC,QAAA,EAA8BC,IAAA,EAA2C;EACxG,OAAOD,QAAA,IAAYR,eAAA,CAAgBS,IAAI,KAAKT,eAAA,CAAgBM,OAAA;AAC9D;AAEO,SAASI,uBAA0BzB,GAAA,EAA6BF,SAAA,EAA6B;EAClG,MAAM4B,MAAA,GAAS1B,GAAA,CAAI2B,OAAA;EACnB,MAAMC,cAAA,GACJ,OAAOF,MAAA,KAAW,WAAW;IAAEG,IAAA,EAAMH,MAAA;IAAQI,KAAA,EAAOJ,MAAA;IAAQK,MAAA,EAAQL,MAAA;IAAQM,GAAA,EAAKN;EAAO,IAAIA,MAAA;EAE9F,MAAMO,GAAA,GAAMjC,GAAA,CAAIkC,GAAA,KAAQ;EACxB,MAAMC,iBAAA,GAAoBrC,SAAA,CACvBsC,OAAA,CAAQ,UAAUH,GAAA,GAAM,WAAW,OAAO,EAC1CG,OAAA,CAAQ,QAAQH,GAAA,GAAM,UAAU,QAAQ;EAE3C,MAAMI,QAAA,GAAWF,iBAAA,CAAkBG,QAAA,CAAS,OAAO;EACnD,MAAMC,OAAA,GAAUJ,iBAAA,CAAkBG,QAAA,CAAS,MAAM;EAEjD,MAAME,MAAA,GAAgB;IACpBC,QAAA,EAAU;IACVC,aAAA,EAAe1C,GAAA,CAAI2C,KAAA,GAAQ,IAAI,SAAY;IAC3CC,OAAA,EAAS;IACTC,aAAA,EAAe;IACf,SAAS,GAAG7C,GAAA,CAAI8C,GAAG;IACnB,kBAAkB,GAAG9C,GAAA,CAAI+C,OAAA,CAAQ,CAAC,GAAGC,MAAA,IAAU,CAAC;IAChDC,MAAA,EAAQzC;EACV;EAEA,IAAI0C,UAAA,GAAkC;EACtC,IAAIb,QAAA,EAAUa,UAAA,GAAa;EAC3B,IAAIX,OAAA,EAASW,UAAA,GAAa;EAE1BV,MAAA,CAAOU,UAAA,GAAaA,UAAA;EAEpB,IAAIf,iBAAA,CAAkBG,QAAA,CAAS,KAAK,GAAG;IACrC,MAAMa,OAAA,GAASvB,cAAA,CAAeI,GAAA;IAC9BQ,MAAA,CAAOR,GAAA,GAAM,sCAAsCmB,OAAM;EAC3D;EAEA,IAAIhB,iBAAA,CAAkBG,QAAA,CAAS,QAAQ,GAAG;IACxC,MAAMa,OAAA,GAASvB,cAAA,CAAeG,MAAA;IAC9BS,MAAA,CAAOT,MAAA,GAAS,yCAAyCoB,OAAM;EACjE;EAEA,IAAI,CAAChB,iBAAA,CAAkBG,QAAA,CAAS,MAAM,GAAG;IACvC,MAAMa,OAAA,GAASvB,cAAA,CAAeE,KAAA;IAC9BU,MAAA,CAAOY,cAAA,GAAiB,0CAA0CD,OAAM;EAC1E;EAEA,IAAI,CAAChB,iBAAA,CAAkBG,QAAA,CAAS,OAAO,GAAG;IACxC,MAAMa,OAAA,GAASvB,cAAA,CAAeC,IAAA;IAC9BW,MAAA,CAAOa,gBAAA,GAAmB,yCAAyCF,OAAM;EAC3E;EAEA,OAAOX,MAAA;AACT;AAEO,SAASc,kBAAqBtD,GAAA,EAAwBuD,OAAA,EAAyB;EACpF,MAAM,CAACC,IAAI,IAAIxD,GAAA,CAAIF,SAAA,CAAW2D,KAAA,CAAM,GAAG;EACvC,MAAMC,OAAA,GAAU,CAAC1D,GAAA,CAAI2D,SAAA;EACrB,MAAMC,OAAA,GAAU,CAAC5D,GAAA,CAAI6D,OAAA;EAErB,MAAMrB,MAAA,GAAgB;IACpBC,QAAA,EAAU;IACVC,aAAA,EAAe;IACf,aAAa;IACb,kBAAkB,GAAG1C,GAAA,CAAI8D,WAAW;IACpC,cAAc,GAAG9D,GAAA,CAAIwB,IAAA,KAAS,YAAYuC,MAAA,CAAOC,gBAAA,GAAmBhE,GAAA,CAAIuB,QAAQ;IAChF,oBAAoB,GAAGvB,GAAA,CAAIgD,MAAM;IACjC,YAAY,GAAGhD,GAAA,CAAI0B,MAAM;IACzB,WAAW1B,GAAA,CAAIiE,KAAA;IACf,aAAajE,GAAA,CAAIiD,MAAA;IACjB,iBAAiB;IACjB,OAAO;IACP,OAAO;EACT;EAEA,MAAMiB,MAAA,GAAUC,SAAA,IAAqBC,MAAA,CAAOF,MAAA,CAAO1B,MAAA,EAAQ2B,SAAS;EAEpE,IAAIX,IAAA,KAAS,OAAO;IAElBU,MAAA,CAAO;MACLlC,GAAA,EAAK;MACL,UAAU;MACV,OAAO;MACP,UAAU;IACZ,CAAC;EAEH,WAAWwB,IAAA,KAAS,UAAU;IAE5BU,MAAA,CAAO;MACLnC,MAAA,EAAQ;MACR,UAAU;MACV,OAAO;MACP,UAAU;IACZ,CAAC;EACH;EAEA,IAAI/B,GAAA,CAAIqE,OAAA,EAAS;IACfH,MAAA,CAAO;MACL,OAAO;MACP,aAAa;IACf,CAAC;IAED,IAAIlE,GAAA,CAAI6D,OAAA,EAAS;MACfK,MAAA,CAAO;QACL,OAAO;QACP,YAAY;MACd,CAAC;IACH;EACF;EAEA,IAAI,CAACX,OAAA,EAAS;IACZW,MAAA,CAAO;MACL,aAAa;MACbxB,aAAA,EAAe;IACjB,CAAC;EACH;EAEA,IAAIgB,OAAA,IAAWE,OAAA,EAAS;IACtBM,MAAA,CAAO;MACL,gBAAgB;MAChB,OAAO;MACP,WAAW;MACX,YAAY;IACd,CAAC;IAED,IAAI,CAACX,OAAA,EAAS;MACZW,MAAA,CAAO;QACL,OAAO;MACT,CAAC;IACH;EACF;EAEA,IAAIR,OAAA,IAAW1D,GAAA,CAAI6D,OAAA,IAAW,CAACN,OAAA,EAAS;IACtCW,MAAA,CAAO;MACL,OAAO;IACT,CAAC;EACH;EAEA,IAAIlE,GAAA,CAAI2D,SAAA,IAAa,CAACJ,OAAA,EAAS;IAC7BW,MAAA,CAAO;MACL,OAAO;IACT,CAAC;EACH;EAEA,OAAO1B,MAAA;AACT;AAEO,SAAS8B,oBAAuBtE,GAAA,EAAwBuD,OAAA,EAAyB;EACtF,MAAMf,MAAA,GAAgB;IACpBC,QAAA,EAAU;IACV8B,KAAA,EAAO;IACPC,KAAA,EAAO;IACP9B,aAAA,EAAea,OAAA,GAAU,SAAS;EACpC;EAEA,MAAMW,MAAA,GAAUC,SAAA,IAAqBC,MAAA,CAAOF,MAAA,CAAO1B,MAAA,EAAQ2B,SAAS;EAEpE,IAAInE,GAAA,CAAI2D,SAAA,IAAa,CAACJ,OAAA,EAAS;IAC7BW,MAAA,CAAO;MACLlB,MAAA,EAAQ;IACV,CAAC;EACH;EAEA,OAAOR,MAAA;AACT;AAEO,SAASiC,mBAAsBC,IAAA,EAAyBC,QAAA,EAA0B;EACvF,OAAO;IACLlC,QAAA,EAAU;IACVZ,IAAA,EAAM;IACNmB,MAAA,EAAQ;IACRjB,MAAA,EAAQ;IACR6C,KAAA,EAAO;EACT;AACF;;;AHtLO,SAASC,aACdC,cAAA,EACAC,IAAA,EACAC,SAAA,EACuB;EAGvB,SAASC,SAAA,EAA0B;IACjC,MAAMC,MAAA,GAAShG,SAAA,CAAU4F,cAAc,IAAIA,cAAA,CAAeG,QAAA,CAAS,IAAIH,cAAA;IACvE,OAAOI,MAAA;EACT;EAEA,SAASC,yBAAyBrF,SAAA,EAAsB;IACtD,OAAOW,oBAAA,CAAqBwE,QAAA,CAAS,EAAEnE,OAAA,CAAQJ,MAAA,EAAQZ,SAAS;EAClE;EAEA,SAASsF,UAAUjF,EAAA,EAAY;IAC7B,MAAMO,MAAA,GAASuE,QAAA,CAAS,EAAEnE,OAAA,CAAQJ,MAAA;IAClC,IAAI,CAACA,MAAA,CAAO2E,MAAA,EAAQ,OAAO;IAC3B,OAAO,CAAC,CAAC3E,MAAA,CAAO4E,IAAA,CAAM1E,KAAA,IAAUA,KAAA,CAAMT,EAAA,IAAMA,EAAE;EAChD;EAEA,SAASoF,OAAOC,OAAA,EAAqB;IACnC,MAAMC,GAAA,GAAM,SAASnG,IAAA,CAAK,CAAC;IAC3B,MAAMa,EAAA,GAAKqF,OAAA,CAAQrF,EAAA,GAAKqF,OAAA,CAAQrF,EAAA,GAAKsF,GAAA;IAErC,IAAIL,SAAA,CAAUjF,EAAE,GAAG,OAAOA,EAAA;IAC1B4E,IAAA,CAAK;MAAEvD,IAAA,EAAM;MAAaZ,KAAA,EAAO;QAAE,GAAG4E,OAAA;QAASrF;MAAG;IAAE,CAAC;IAErD,OAAOA,EAAA;EACT;EAEA,SAASuF,OAAOvF,EAAA,EAAYqF,OAAA,EAAqB;IAC/C,IAAI,CAACJ,SAAA,CAAUjF,EAAE,GAAG,OAAOA,EAAA;IAC3B4E,IAAA,CAAK;MAAEvD,IAAA,EAAM;MAAgBrB,EAAA;MAAIS,KAAA,EAAO4E;IAAQ,CAAC;IACjD,OAAOrF,EAAA;EACT;EAEA,SAASwF,OAAOH,OAAA,EAAqB;IACnC,MAAM;MAAErF;IAAG,IAAIqF,OAAA;IACf,MAAMjC,OAAA,GAAUpD,EAAA,GAAKiF,SAAA,CAAUjF,EAAE,IAAI;IACrC,IAAIoD,OAAA,IAAWpD,EAAA,IAAM,MAAM;MACzB,OAAOuF,MAAA,CAAOvF,EAAA,EAAIqF,OAAO;IAC3B,OAAO;MACL,OAAOD,MAAA,CAAOC,OAAO;IACvB;EACF;EAEA,SAASI,QAAQzF,EAAA,EAAa;IAC5B,IAAIA,EAAA,IAAM,MAAM;MACd4E,IAAA,CAAK,aAAa;IACpB,WAAWK,SAAA,CAAUjF,EAAE,GAAG;MACxB4E,IAAA,CAAK;QAAEvD,IAAA,EAAM;QAAiBrB;MAAG,CAAC;IACpC;EACF;EAEA,OAAO;IACL0F,SAAA,EAAW;MACT,OAAOZ,QAAA,CAAS,EAAEnE,OAAA,CAAQ6B,KAAA;IAC5B;IACAmD,cAAA,EAAgB;MACd,MAAMpF,MAAA,GAASuE,QAAA,CAAS,EAAEnE,OAAA,CAAQJ,MAAA;MAClC,MAAMqF,UAAA,GAAarF,MAAA,CAAOsF,GAAA,CAAKpF,KAAA,IAAUA,KAAA,CAAMC,KAAA,CAAMC,OAAA,CAAQhB,SAAU;MACvE,OAAOmG,KAAA,CAAMC,IAAA,CAAK,IAAIC,GAAA,CAAIJ,UAAU,CAAC;IACvC;IACAtF,oBAAA,EAAsB0E,wBAAA;IACtBC,SAAA;IACAG,MAAA;IACAG,MAAA;IACAC,MAAA;IACAC,OAAA;IAEAQ,OAAOjG,EAAA,EAAI;MACT,IAAIA,EAAA,IAAM,MAAM;QACd4E,IAAA,CAAK,YAAY;MACnB,WAAWK,SAAA,CAAUjF,EAAE,GAAG;QACxB4E,IAAA,CAAK;UAAEvD,IAAA,EAAM;UAAgBrB;QAAG,CAAC;MACnC;IACF;IAEAkG,mBAAmBvG,SAAA,EAAW;MAC5B,MAAMY,MAAA,GAASyE,wBAAA,CAAyBrF,SAAS;MACjDY,MAAA,CAAO4F,OAAA,CAAS1F,KAAA,IAAUgF,OAAA,CAAQhF,KAAA,CAAMT,EAAE,CAAC;IAC7C;IACAgB,QAAQqE,OAAA,EAAS;MACf,OAAOG,MAAA,CAAO;QAAE,GAAGH,OAAA;QAAShE,IAAA,EAAM;MAAU,CAAC;IAC/C;IACAN,QAAQsE,OAAA,EAAS;MACf,OAAOG,MAAA,CAAO;QAAE,GAAGH,OAAA;QAAShE,IAAA,EAAM;MAAU,CAAC;IAC/C;IACAP,MAAMuE,OAAA,EAAS;MACb,OAAOG,MAAA,CAAO;QAAE,GAAGH,OAAA;QAAShE,IAAA,EAAM;MAAQ,CAAC;IAC7C;IAEA+E,QAAQA,OAAA,EAASf,OAAA,EAAsB;MAAA,IAAbgB,MAAA,GAAAC,SAAA,CAAApB,MAAA,QAAAoB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAS,CAAC;MAClC,MAAMtG,EAAA,GAAKwF,MAAA,CAAO;QAAE,GAAGa,MAAA;QAAQ,GAAGhB,OAAA,CAAQrE,OAAA;QAASK,IAAA,EAAM;MAAU,CAAC;MAEpEnC,OAAA,CAAQkH,OAAO,EACZI,IAAA,CAAMC,QAAA,IAAa;QAClB,MAAMC,cAAA,GAAiBxH,OAAA,CAAQmG,OAAA,CAAQtE,OAAA,EAAS0F,QAAQ;QACxDjB,MAAA,CAAO;UAAE,GAAGa,MAAA;UAAQ,GAAGK,cAAA;UAAgB1G,EAAA;UAAIqB,IAAA,EAAM;QAAU,CAAC;MAC9D,CAAC,EACAsF,KAAA,CAAO7F,KAAA,IAAU;QAChB,MAAM8F,YAAA,GAAe1H,OAAA,CAAQmG,OAAA,CAAQvE,KAAA,EAAOA,KAAK;QACjD0E,MAAA,CAAO;UAAE,GAAGa,MAAA;UAAQ,GAAGO,YAAA;UAAc5G,EAAA;UAAIqB,IAAA,EAAM;QAAQ,CAAC;MAC1D,CAAC,EACAwF,OAAA,CAAQ,MAAM;QACbxB,OAAA,CAAQwB,OAAA,GAAU;MACpB,CAAC;MAEH,OAAO7G,EAAA;IACT;IAEA8G,MAAM9G,EAAA,EAAI;MACR,IAAIA,EAAA,IAAM,MAAM;QACd4E,IAAA,CAAK,WAAW;MAClB,WAAWK,SAAA,CAAUjF,EAAE,GAAG;QACxB4E,IAAA,CAAK;UAAEvD,IAAA,EAAM;UAAerB;QAAG,CAAC;MAClC;IACF;IAEA+G,OAAO/G,EAAA,EAAI;MACT,IAAIA,EAAA,IAAM,MAAM;QACd4E,IAAA,CAAK,YAAY;MACnB,WAAWK,SAAA,CAAUjF,EAAE,GAAG;QACxB4E,IAAA,CAAK;UAAEvD,IAAA,EAAM;UAAgBrB;QAAG,CAAC;MACnC;IACF;IAEAgH,cAAc3B,OAAA,EAAS;MACrB,MAAM;QAAE1F,SAAA;QAAWsH,KAAA,GAAQ;MAAgB,IAAI5B,OAAA;MAC/C,MAAM3E,KAAA,GAAQoE,QAAA,CAAS;MACvB,MAAMoC,WAAA,GAAcxG,KAAA,CAAMC,OAAA,CAAQwG,MAAA,CAAOC,IAAA,CAAK,GAAG,EAAEnF,OAAA,CAAQ,QAAQ,EAAE,EAAEA,OAAA,CAAQ,UAAU,EAAE;MAC3F,MAAM,CAACoB,IAAA,EAAMgE,KAAA,GAAQ,QAAQ,IAAI1H,SAAA,CAAU2D,KAAA,CAAM,GAAG;MAEpD,OAAOuB,SAAA,CAAUyC,OAAA,CAAQ;QACvB,GAAGhI,KAAA,CAAMiI,KAAA,CAAMC,KAAA;QACfzF,GAAA,EAAKrB,KAAA,CAAMC,OAAA,CAAQoB,GAAA;QACnB0F,QAAA,EAAU;QACV,cAAc,GAAG9H,SAAS,IAAIsH,KAAK,IAAIC,WAAW;QAClDlH,EAAA,EAAIP,GAAA,CAAIC,WAAA,CAAYC,SAAS;QAC7B,kBAAkBA,SAAA;QAClB,aAAa0D,IAAA;QACb,cAAcgE,KAAA;QACd,aAAa;QACbK,IAAA,EAAM;QACNC,KAAA,EAAOrG,sBAAA,CAAuBZ,KAAA,CAAMC,OAAA,EAAShB,SAAS;QACtDiI,YAAA,EAAc;UACZhD,IAAA,CAAK;YAAEvD,IAAA,EAAM;YAAwB1B;UAAU,CAAC;QAClD;QACAkI,aAAA,EAAe;UACbjD,IAAA,CAAK;YAAEvD,IAAA,EAAM;YAAwB1B;UAAU,CAAC;QAClD;QACAmI,QAAQC,KAAA,EAAO;UACbnD,IAAA,CAAK;YAAEvD,IAAA,EAAM;YAAgB2G,MAAA,EAAQD,KAAA,CAAME;UAAc,CAAC;QAC5D;QACAC,OAAOH,KAAA,EAAO;UACZ,IAAIrH,KAAA,CAAMC,OAAA,CAAQwH,aAAA,IAAiB,CAAClJ,QAAA,CAAS8I,KAAA,CAAMK,aAAA,EAAeL,KAAA,CAAME,aAAa,GAAG;YACtFrD,IAAA,CAAK;cAAEvD,IAAA,EAAM;YAAc,CAAC;UAC9B;QACF;MACF,CAAC;IACH;IAEArC,UAAUqJ,EAAA,EAAI;MACZ,MAAM3H,KAAA,GAAQoE,QAAA,CAAS;MACvB,OAAO9F,SAAA,CAAU0B,KAAA,CAAMC,OAAA,CAAQJ,MAAA,EAAQ,MAAM;QAC3C,MAAMA,MAAA,GAASyE,wBAAA,CAAyBtE,KAAA,CAAMC,OAAA,CAAQhB,SAAS;QAC/D,MAAM2I,QAAA,GAAW/H,MAAA,CAAOsF,GAAA,CAAKpF,KAAA,IAAUA,KAAA,CAAMqE,QAAA,CAAS,EAAEnE,OAAO;QAC/D0H,EAAA,CAAGC,QAAQ;MACb,CAAC;IACH;EACF;AACF;;;AItLA,SAASC,aAAA,IAAAC,cAAA,EAAeC,GAAA,QAAW;AACnC,SAASC,sBAAA,QAA8B;AACvC,SAASC,WAAA,QAAmB;AAC5B,SAASC,OAAA,IAAAC,QAAA,QAAe;;;ACHxB,SAASN,aAAA,EAAeO,MAAA,QAAc;AACtC,SAASC,QAAA,EAAUC,GAAA,QAAW;AAC9B,SAASJ,OAAA,EAASK,IAAA,QAAY;AAK9B,IAAM;EAAEC,GAAA;EAAKC,GAAA;EAAKC;AAAG,IAAIN,MAAA;AAElB,SAASO,mBAAsBhE,OAAA,EAAqB;EACzD,MAAM;IAAEhE,IAAA,GAAO;IAAQD,QAAA;IAAUpB,EAAA,GAAK;IAAKL,SAAA,GAAY;IAAUgE,WAAA,GAAc;IAAK,GAAG2F;EAAU,IAAIjE,OAAA;EACrG,MAAMxF,GAAA,GAAM+I,OAAA,CAAQU,SAAS;EAE7B,MAAMC,gBAAA,GAAmBpI,gBAAA,CAAiBC,QAAA,EAAUC,IAAI;EAExD,OAAOkH,aAAA,CACL;IACEvI,EAAA;IACAW,OAAA,EAAS;MACPX,EAAA;MACAqB,IAAA;MACAmI,SAAA,EAAWD,gBAAA;MACXnI,QAAA,EAAUmI,gBAAA;MACV5F,WAAA;MACA8F,SAAA,EAAWC,IAAA,CAAKC,GAAA,CAAI;MACpBhK,SAAA;MACA,GAAGE,GAAA;MACHgD,MAAA,EAAQ;MACRtB,MAAA,EAAQ;MACRiC,SAAA,EAAW;MACXU,OAAA,EAAS;MACTJ,KAAA,EAAO;MACPhB,MAAA,EAAQ;IACV;IAEA8G,OAAA,EAASvI,IAAA,KAAS,YAAY,oBAAoB;IAElDwI,EAAA,EAAI;MACFC,MAAA,EAAQ,CACN;QACEC,KAAA,EAAOZ,GAAA,CAAI,kBAAkB,qBAAqB;QAClDnB,MAAA,EAAQ;QACRgC,OAAA,EAAS,CAAC,YAAY;MACxB,GACA;QACED,KAAA,EAAOX,EAAA,CAAG,sBAAsB,gBAAgB;QAChDpB,MAAA,EAAQ;QACRgC,OAAA,EAAS,CAAC,YAAY;MACxB,GACA;QACEA,OAAA,EAAS,CAAC,YAAY;MACxB,EACF;MACAC,OAAA,EAAS;QACPD,OAAA,EAAS,CAAC,eAAe;MAC3B;IACF;IAEAE,KAAA,EAAO,CAAC,iBAAiB;IAEzBC,UAAA,EAAY,CAAC,aAAa;IAE1BC,MAAA,EAAQ;MACN,oBAAoB;QAClBC,IAAA,EAAM,CAAC,WAAW,UAAU;QAC5BC,KAAA,EAAO;UACL,GAAG;QACL;MACF;MAEA,mBAAmB;QACjBD,IAAA,EAAM,CAAC,WAAW,QAAQ;QAC1BR,EAAA,EAAI;UACFU,MAAA,EAAQ;YACNR,KAAA,EAAOb,GAAA,CAAI,eAAe;YAC1BlB,MAAA,EAAQ;YACRgC,OAAA,EAAS,CAAC,cAAc;UAC1B;UACAQ,OAAA,EAAS;QACX;MACF;MAEApH,OAAA,EAAS;QACPiH,IAAA,EAAM,CAAC,SAAS;QAChBC,KAAA,EAAO;UACLG,gBAAA,EAAkB;QACpB;QACAZ,EAAA,EAAI;UACFW,OAAA,EAAS;UACTE,KAAA,EAAO;YACL1C,MAAA,EAAQ;YACRgC,OAAA,EAAS;UACX;QACF;MACF;MAEAW,UAAA,EAAY;QACVT,KAAA,EAAO;QACPI,KAAA,EAAO;UACLM,YAAA,EAAc;YACZ5C,MAAA,EAAQ;YACRgC,OAAA,EAAS;UACX;QACF;MACF;MAEAa,SAAA,EAAW;QACTX,KAAA,EAAO;QACP7I,IAAA,EAAM;MACR;IACF;EACF,GACA;IACE8I,UAAA,EAAY;MACVW,YAAYC,IAAA,EAAKC,IAAA,EAAAC,IAAA,EAAgB;QAAA,IAAV;UAAEC;QAAK,IAAAD,IAAA;QAC5B,IAAIE,OAAA;QACJnC,GAAA,CAAI,MAAM;UACR,MAAMoC,MAAA,GAAS3L,GAAA,CAAIQ,SAAA,CAAU8K,IAAG;UAChC,IAAI,CAACK,MAAA,EAAQ;UACbL,IAAA,CAAI7G,OAAA,GAAU;UAEd,MAAMmH,MAAA,GAAStC,QAAA,CAASqC,MAAA,EAAQ,cAAc;UAE9CnC,IAAA,CACEoC,MAAA,CAAOnG,MAAA,KAAW,GAClB,6FACF;UAEA,MAAMoG,UAAA,GAAaA,CAAA,KAAM;YACvB,MAAMC,cAAA,GAAiBH,MAAA,CAAOzD,KAAA,CAAM9E,MAAA;YACpCuI,MAAA,CAAOzD,KAAA,CAAM9E,MAAA,GAAS;YACtB,MAAM2I,SAAA,GAAYJ,MAAA,CAAOK,qBAAA,CAAsB,EAAE5I,MAAA;YACjDuI,MAAA,CAAOzD,KAAA,CAAM9E,MAAA,GAAS0I,cAAA;YAEtBR,IAAA,CAAIlI,MAAA,GAAS2I,SAAA;YACbN,IAAA,CAAKQ,UAAA,CAAW;cAAErK,IAAA,EAAM;cAAiBrB,EAAA,EAAIkL,IAAA,CAAKlL,EAAA;cAAI6C,MAAA,EAAQ2I,SAAA;cAAW7L,SAAA,EAAWoL,IAAA,CAAIpL;YAAU,CAAC;UACrG;UAEA2L,UAAA,CAAW;UAEX,MAAMK,GAAA,GAAMlM,GAAA,CAAImM,MAAA,CAAOb,IAAG;UAE1B,MAAMc,QAAA,GAAW,IAAIF,GAAA,CAAIG,gBAAA,CAAiBR,UAAU;UACpDO,QAAA,CAASE,OAAA,CAAQX,MAAA,EAAQ;YAAEY,SAAA,EAAW;YAAMC,OAAA,EAAS;YAAMC,aAAA,EAAe;UAAK,CAAC;UAEhFf,OAAA,GAAUA,CAAA,KAAMU,QAAA,CAASM,UAAA,CAAW;QACtC,CAAC;QAED,OAAO,MAAMhB,OAAA,GAAU;MACzB;IACF;IAEArC,MAAA,EAAQ;MACNsD,mBAAA,EAAqBA,CAACC,CAAA,EAAGC,GAAA,KAAQA,GAAA,CAAI7L,KAAA,EAAOY,IAAA,KAAS;MACrDkL,aAAA,EAAgBxB,IAAA,IAAQA,IAAA,CAAI1J,IAAA,KAAS;MACrCmL,cAAA,EAAgBA,CAACzB,IAAA,EAAKuB,GAAA,KAAQA,GAAA,CAAI7L,KAAA,EAAOY,IAAA,IAAQ,QAAQiL,GAAA,CAAI7L,KAAA,CAAMY,IAAA,KAAS0J,IAAA,CAAI1J,IAAA;MAChFoL,kBAAA,EAAoBA,CAAC1B,IAAA,EAAKuB,GAAA,KAAQA,GAAA,CAAI7L,KAAA,EAAOW,QAAA,IAAY,QAAQkL,GAAA,CAAI7L,KAAA,CAAMW,QAAA,KAAa2J,IAAA,CAAI3J;IAC9F;IAEAsL,MAAA,EAAQ;MACNjC,gBAAA,EAAmBM,IAAA,IAAQA,IAAA,CAAIvB,SAAA;MAC/BoB,YAAA,EAAeG,IAAA,IAAQA,IAAA,CAAIpH;IAC7B;IAEAqG,OAAA,EAAS;MACP2C,cAAc5B,IAAA,EAAKC,IAAA,EAAA4B,KAAA,EAAgB;QAAA,IAAV;UAAE1B;QAAK,IAAA0B,KAAA;QAC9B5D,GAAA,CAAI,MAAM;UACR,MAAMoC,MAAA,GAAS3L,GAAA,CAAIQ,SAAA,CAAU8K,IAAG;UAChC,IAAI,CAACK,MAAA,EAAQ;UAEbL,IAAA,CAAI7G,OAAA,GAAU;UAEd,MAAMqH,cAAA,GAAiBH,MAAA,CAAOzD,KAAA,CAAM9E,MAAA;UACpCuI,MAAA,CAAOzD,KAAA,CAAM9E,MAAA,GAAS;UAEtB,MAAM2I,SAAA,GAAYJ,MAAA,CAAOK,qBAAA,CAAsB,EAAE5I,MAAA;UACjDuI,MAAA,CAAOzD,KAAA,CAAM9E,MAAA,GAAS0I,cAAA;UACtBR,IAAA,CAAIlI,MAAA,GAAS2I,SAAA;UAEbN,IAAA,CAAKQ,UAAA,CAAW;YAAErK,IAAA,EAAM;YAAiBrB,EAAA,EAAIkL,IAAA,CAAKlL,EAAA;YAAI6C,MAAA,EAAQ2I,SAAA;YAAW7L,SAAA,EAAWoL,IAAA,CAAIpL;UAAU,CAAC;QACrG,CAAC;MACH;MACAkN,qBAAqB9B,IAAA,EAAK;QACxBA,IAAA,CAAIvB,SAAA,IAAaE,IAAA,CAAKC,GAAA,CAAI,IAAIoB,IAAA,CAAItB,SAAA;MACpC;MACAqD,aAAa/B,IAAA,EAAK;QAChBA,IAAA,CAAItB,SAAA,GAAYC,IAAA,CAAKC,GAAA,CAAI;MAC3B;MACAoD,qBAAqBxI,IAAA,EAAMyG,IAAA,EAAAgC,KAAA,EAAgB;QAAA,IAAV;UAAE9B;QAAK,IAAA8B,KAAA;QACtC9B,IAAA,CAAKQ,UAAA,CAAW;UAAErK,IAAA,EAAM;UAAgBrB,EAAA,EAAIkL,IAAA,CAAKlL;QAAG,CAAC;MACvD;MACAiN,gBAAgBlC,IAAA,EAAK;QACnBA,IAAA,CAAImC,cAAA,GAAiB;UAAEC,MAAA,EAAQ;QAAa,CAAC;MAC/C;MACAC,gBAAgBrC,IAAA,EAAK;QACnBA,IAAA,CAAImC,cAAA,GAAiB;UAAEC,MAAA,EAAQ;QAAY,CAAC;MAC9C;MACAE,gBAAgBtC,IAAA,EAAK;QACnBA,IAAA,CAAImC,cAAA,GAAiB;UAAEC,MAAA,EAAQ;QAAU,CAAC;MAC5C;MACAG,WAAWvC,IAAA,EAAKuB,GAAA,EAAK;QACnB,MAAMiB,SAAA,GAAWjB,GAAA,CAAI7L,KAAA,EAAOW,QAAA;QAC5B,MAAMoM,KAAA,GAAOlB,GAAA,CAAI7L,KAAA,EAAOY,IAAA,IAAQ0J,IAAA,CAAI1J,IAAA;QAEpC,MAAMoM,iBAAA,GAAmBtM,gBAAA,CAAiBoM,SAAA,EAAUC,KAAI;QAExDvJ,MAAA,CAAOF,MAAA,CAAOgH,IAAA,EAAK;UACjB,GAAGuB,GAAA,CAAI7L,KAAA;UACPW,QAAA,EAAUqM,iBAAA;UACVjE,SAAA,EAAWiE;QACb,CAAC;MACH;IACF;EACF,CACF;AACF;;;ADxMO,SAASC,aAAsBC,WAAA,EAAsC;EAC1E,MAAM9N,GAAA,GAAMgJ,QAAA,CAAQ8E,WAAW;EAC/B,OAAOnF,cAAA,CACL;IACExI,EAAA,EAAI;IACJ4J,OAAA,EAAS/J,GAAA,CAAI4D,OAAA,GAAU,YAAY;IACnC9C,OAAA,EAAS;MACPoB,GAAA,EAAK;MACL6L,GAAA,EAAKhK,MAAA,CAAOC,gBAAA;MACZlB,GAAA,EAAK;MACLkL,eAAA,EAAiB;MACjB1G,MAAA,EAAQ,CAAC,UAAU,MAAM;MACzB3F,OAAA,EAAS;MACT7B,SAAA,EAAW;MACXgE,WAAA,EAAa;MACb,GAAG9D,GAAA;MACHU,MAAA,EAAQ,EAAC;MACTuN,aAAA,EAAe;MACf3F,aAAA,EAAe;MACfvF,OAAA,EAAS;IACX;IAEAmL,QAAA,EAAU;MACRvL,KAAA,EAAQuI,IAAA,IAAQA,IAAA,CAAIxK,MAAA,CAAO2E;IAC7B;IAEAiF,UAAA,EAAY,CAAC,2BAA2B,kBAAkB;IAE1D6D,KAAA,EAAO;MACLzN,MAAA,EAAQ,CAAC,oBAAoB,sBAAsB;IACrD;IAEA0N,IAAA,EAAM,CAAC,gBAAgB,0BAA0B,oBAAoB;IAErEpE,EAAA,EAAI;MACFqE,WAAA,EAAa;QACXlE,OAAA,EAAS,CAAC,YAAY;MACxB;MACAmE,SAAA,EAAW;QACTnE,OAAA,EAAS,CAAC,aAAa;MACzB;MACAoE,YAAA,EAAc;QACZpE,OAAA,EAAS,CAAC,aAAa;MACzB;MACAqE,UAAA,EAAY;QACVrE,OAAA,EAAS,CAAC,cAAc;MAC1B;MACAsE,SAAA,EAAW;QACTvE,KAAA,EAAO;QACPC,OAAA,EAAS,CAAC,eAAe,gBAAgB;MAC3C;MACAuE,YAAA,EAAc;QACZvE,OAAA,EAAS,CAAC,aAAa;MACzB;MACAwE,aAAA,EAAe;QACbxE,OAAA,EAAS,CAAC,cAAc;MAC1B;MACAyE,WAAA,EAAa;QACXzE,OAAA,EAAS,CAAC,eAAe;MAC3B;MACA0E,YAAA,EAAc;QACZ1E,OAAA,EAAS,CAAC,eAAe,kBAAkB,iBAAiB;MAC9D;MACA2E,UAAA,EAAY;QACV3E,OAAA,EAAS,CAAC,cAAc;MAC1B;MACA4E,aAAA,EAAe;QACb5E,OAAA,EAAS,CAAC,eAAe,iBAAiB;MAC5C;MACA,cAAc;QACZA,OAAA,EAAS,CAAC,eAAe;MAC3B;MACA,eAAe,CACb;QACED,KAAA,EAAO;QACP/B,MAAA,EAAQ;QACRgC,OAAA,EAAS,CAAC,gBAAgB,sBAAsB;MAClD,GACA;QACEA,OAAA,EAAS,CAAC,gBAAgB,sBAAsB;MAClD;IAEJ;IAEAI,MAAA,EAAQ;MACNyE,KAAA,EAAO;QACL3E,KAAA,EAAO,CAAC,cAAc;QACtBL,EAAA,EAAI;UACF,wBAAwB,CACtB;YACEE,KAAA,EAAO;YACP/B,MAAA,EAAQ;YACRgC,OAAA,EAAS,CAAC,cAAc;UAC1B,GACA;YACEA,OAAA,EAAS,CAAC,cAAc;UAC1B,EACF;UACA,kBAAkB;YAChBhC,MAAA,EAAQ;UACV;UACA,gBAAgB;YACdgC,OAAA,EAAS,CAAC,oBAAoB,aAAa;UAC7C;UACA,wBAAwB;YACtBA,OAAA,EAAS,CAAC,aAAa;UACzB;QACF;MACF;MACAvG,OAAA,EAAS;QACPyG,KAAA,EAAO,CAAC,gBAAgB;QACxBL,EAAA,EAAI;UACF,gBAAgB;YACd7B,MAAA,EAAQ;UACV;UACA,wBAAwB;YACtBA,MAAA,EAAQ;YACRgC,OAAA,EAAS,CAAC,aAAa;UACzB;UACA,gBAAgB;YACdhC,MAAA,EAAQ;YACRgC,OAAA,EAAS,CAAC,oBAAoB,aAAa;UAC7C;QACF;MACF;IACF;EACF,GACA;IACElB,MAAA,EAAQ;MACNgG,aAAA,EAAgB/D,IAAA,IAAQA,IAAA,CAAIxK,MAAA,CAAO2E,MAAA,GAAS6F,IAAA,CAAI6C,GAAA;MAChDmB,aAAA,EAAgBhE,IAAA,IAAQ,CAAC,CAACA,IAAA,CAAItH;IAChC;IACA0G,UAAA,EAAY;MACV6E,iBAAiBjE,IAAA,EAAKC,IAAA,EAAAiE,KAAA,EAAgB;QAAA,IAAV;UAAErK;QAAK,IAAAqK,KAAA;QACjC,MAAMC,aAAA,GAAiBnH,KAAA,IAAyB;UAC9C,MAAMoH,eAAA,GAAkBpE,IAAA,CAAI5D,MAAA,CAAOiI,KAAA,CAAOC,GAAA,IAAStH,KAAA,CAAcsH,GAAG,KAAKtH,KAAA,CAAMuH,IAAA,KAASD,GAAG;UAC3F,IAAI,CAACF,eAAA,EAAiB;UACtBvK,IAAA,CAAK;YAAEvD,IAAA,EAAM;UAAa,CAAC;QAC7B;QACA,OAAOsH,WAAA,CAAY4G,QAAA,EAAU,WAAWL,aAAA,EAAe;UAAEM,OAAA,EAAS;QAAK,CAAC;MAC1E;MACAC,wBAAwB1E,IAAA,EAAKC,IAAA,EAAA0E,KAAA,EAAgB;QAAA,IAAV;UAAE9K;QAAK,IAAA8K,KAAA;QACxC,IAAI,CAAC3E,IAAA,CAAI8C,eAAA,EAAiB;QAC1B,MAAM8B,GAAA,GAAMlQ,GAAA,CAAImQ,MAAA,CAAO7E,IAAG;QAC1B,OAAOpC,WAAA,CAAYgH,GAAA,EAAK,oBAAoB,MAAM;UAChD/K,IAAA,CAAK+K,GAAA,CAAIE,eAAA,KAAoB,WAAW,cAAc,YAAY;QACpE,CAAC;MACH;IACF;IACA7F,OAAA,EAAS;MACP8F,qBAAqB/E,IAAA,EAAK;QACxB,MAAMgF,aAAA,GAAgBzP,oBAAA,CAAqByK,IAAA,CAAIxK,MAAA,EAAQwK,IAAA,CAAIpL,SAAS;QACpE,MAAMqQ,SAAA,GAAYD,aAAA,CAAc7K,MAAA,GAAS;QAEzC,IAAI,CAAC8K,SAAA,EAAW;UACdjF,IAAA,CAAIkF,QAAA,GAAW;UACf;QACF;QAEA,IAAID,SAAA,IAAajF,IAAA,CAAIkF,QAAA,EAAU;UAC7B;QACF;QAIA,MAAMC,OAAA,GAAUA,CAAA,KAAMzQ,GAAA,CAAIG,WAAA,CAAYmL,IAAA,EAAKA,IAAA,CAAIpL,SAAS;QACxDoL,IAAA,CAAIkF,QAAA,GAAWvH,sBAAA,CAAuBwH,OAAA,EAAS;UAAEC,KAAA,EAAO;QAAK,CAAC;MAChE;MACAC,uBAAuBrF,IAAA,EAAK;QAC1BA,IAAA,CAAIkF,QAAA,GAAW;MACjB;MACAI,cAActF,IAAA,EAAK;QACjBuF,cAAA,CAAe,MAAM;UACnB7Q,GAAA,CAAIG,WAAA,CAAYmL,IAAA,EAAKA,IAAA,CAAIpL,SAAS,GAAG4Q,KAAA,CAAM;QAC7C,CAAC;MACH;MACAC,aAAazF,IAAA,EAAK;QAChB0F,IAAA,CAAK1F,IAAA,EAAMtK,KAAA,IAAU;UACnBA,KAAA,CAAMC,KAAA,CAAMC,OAAA,CAAQ+C,OAAA,GAAU;QAChC,CAAC;MACH;MACAgN,eAAe3F,IAAA,EAAK;QAClB0F,IAAA,CAAK1F,IAAA,EAAMtK,KAAA,IAAU;UACnBA,KAAA,CAAMC,KAAA,CAAMC,OAAA,CAAQ+C,OAAA,GAAU;QAChC,CAAC;MACH;MACAiN,iBAAiB5F,IAAA,EAAKC,IAAA,EAAA4F,KAAA,EAAgB;QAAA,IAAV;UAAEhM;QAAK,IAAAgM,KAAA;QACjC,IAAI,CAAC7F,IAAA,CAAItH,OAAA,IAAWsH,IAAA,CAAIxK,MAAA,CAAO2E,MAAA,GAAS,GAAG;QAC3CN,IAAA,CAAK,gBAAgB;MACvB;MACAiM,WAAWtM,IAAA,EAAM+H,GAAA,EAAAwE,KAAA,EAAe;QAAA,IAAV;UAAE5F;QAAK,IAAA4F,KAAA;QAC3B5F,IAAA,CAAK6F,SAAA,CAAU,SAASzE,GAAA,CAAItM,EAAE;MAChC;MACAgR,YAAYjG,IAAA,EAAK;QACfA,IAAA,CAAIxK,MAAA,CAAO4F,OAAA,CAAS1F,KAAA,IAAUA,KAAA,CAAMmE,IAAA,CAAK,OAAO,CAAC;MACnD;MACAqM,YAAY1M,IAAA,EAAM+H,GAAA,EAAA4E,KAAA,EAAe;QAAA,IAAV;UAAEhG;QAAK,IAAAgG,KAAA;QAC5BhG,IAAA,CAAK6F,SAAA,CAAU,UAAUzE,GAAA,CAAItM,EAAE;MACjC;MACAmR,aAAapG,IAAA,EAAK;QAChBA,IAAA,CAAIxK,MAAA,CAAO4F,OAAA,CAAS1F,KAAA,IAAUA,KAAA,CAAMmE,IAAA,CAAK,QAAQ,CAAC;MACpD;MACAwM,cAAcrG,IAAA,EAAK;QACjBA,IAAA,CAAIxK,MAAA,CAAO4F,OAAA,CAAS1F,KAAA,IAAUA,KAAA,CAAMmE,IAAA,CAAK,SAAS,CAAC;MACrD;MACAyM,YAAYtG,IAAA,EAAKuB,GAAA,EAAAgF,KAAA,EAAyB;QAAA,IAApB;UAAEpG,IAAA;UAAMpG;QAAS,IAAAwM,KAAA;QACrC,MAAMjM,OAAA,GAA6B;UACjC1F,SAAA,EAAWoL,IAAA,CAAIpL,SAAA;UACfyB,QAAA,EAAU2J,IAAA,CAAI3J,QAAA;UACduC,WAAA,EAAaoH,IAAA,CAAIpH,WAAA;UACjB,GAAG2I,GAAA,CAAI7L,KAAA;UACPsB,GAAA,EAAKgJ,IAAA,CAAIhJ,GAAA;UACTwP,WAAA,EAAaxG,IAAA,CAAIwG,WAAA;UACjB7N,OAAA,EAASoB,QAAA,CAAS,EAAE0M,OAAA,CAAQ,OAAO;QACrC;QAEA,MAAM/Q,KAAA,GAAQ4I,kBAAA,CAAmBhE,OAAO;QAExC,MAAMoM,KAAA,GAAQvG,IAAA,CAAKwG,KAAA,CAAMjR,KAAK;QAC9BsK,IAAA,CAAIxK,MAAA,GAAS,CAACkR,KAAA,EAAO,GAAG1G,IAAA,CAAIxK,MAAM;MACpC;MACAoR,YAAYpN,IAAA,EAAM+H,GAAA,EAAAsF,MAAA,EAAe;QAAA,IAAV;UAAE1G;QAAK,IAAA0G,MAAA;QAC5B1G,IAAA,CAAK6F,SAAA,CAAU;UAAE1P,IAAA,EAAM;UAAUZ,KAAA,EAAO6L,GAAA,CAAI7L;QAAM,GAAG6L,GAAA,CAAItM,EAAE;MAC7D;MACA6R,aAAatN,IAAA,EAAM+H,GAAA,EAAAwF,MAAA,EAAe;QAAA,IAAV;UAAE5G;QAAK,IAAA4G,MAAA;QAC7B5G,IAAA,CAAK6F,SAAA,CAAU,WAAWzE,GAAA,CAAItM,EAAE;MAClC;MACA+R,cAAchH,IAAA,EAAK;QACjBA,IAAA,CAAIxK,MAAA,CAAO4F,OAAA,CAAS1F,KAAA,IAAUA,KAAA,CAAMmE,IAAA,CAAK,SAAS,CAAC;MACrD;MACAoN,YAAYjH,IAAA,EAAKuB,GAAA,EAAA2F,MAAA,EAAe;QAAA,IAAV;UAAE/G;QAAK,IAAA+G,MAAA;QAC3B/G,IAAA,CAAKgH,SAAA,CAAU5F,GAAA,CAAItM,EAAE;QACrB+K,IAAA,CAAIxK,MAAA,GAASwK,IAAA,CAAIxK,MAAA,CAAOC,MAAA,CAAQC,KAAA,IAAUA,KAAA,CAAMT,EAAA,KAAOsM,GAAA,CAAItM,EAAE;QAC7D+K,IAAA,CAAInI,OAAA,GAAUmI,IAAA,CAAInI,OAAA,CAAQpC,MAAA,CAAQqC,MAAA,IAAWA,MAAA,CAAO7C,EAAA,KAAOsM,GAAA,CAAItM,EAAE;MACnE;MACAmS,aAAapH,IAAA,EAAKC,IAAA,EAAAoH,MAAA,EAAgB;QAAA,IAAV;UAAElH;QAAK,IAAAkH,MAAA;QAC7BrH,IAAA,CAAIxK,MAAA,CAAO4F,OAAA,CAAS1F,KAAA,IAAUyK,IAAA,CAAKgH,SAAA,CAAUzR,KAAA,CAAMT,EAAE,CAAC;QACtD+K,IAAA,CAAIxK,MAAA,GAAS,EAAC;QACdwK,IAAA,CAAInI,OAAA,GAAU,EAAC;MACjB;MACAyP,YAAYtH,IAAA,EAAKuB,GAAA,EAAK;QACpB,MAAMgG,QAAA,GAAWvH,IAAA,CAAInI,OAAA,CAAQuC,IAAA,CAAMtC,MAAA,IAAWA,MAAA,CAAO7C,EAAA,KAAOsM,GAAA,CAAItM,EAAE;QAClE,IAAIsS,QAAA,EAAU;UACZA,QAAA,CAASzP,MAAA,GAASyJ,GAAA,CAAIzJ,MAAA;UACtByP,QAAA,CAAS3S,SAAA,GAAY2M,GAAA,CAAI3M,SAAA;QAC3B,OAAO;UACL,MAAM6L,SAAA,GAAY;YAAExL,EAAA,EAAIsM,GAAA,CAAItM,EAAA;YAAI6C,MAAA,EAAQyJ,GAAA,CAAIzJ,MAAA;YAAQlD,SAAA,EAAW2M,GAAA,CAAI3M;UAAU;UAC7EoL,IAAA,CAAInI,OAAA,GAAU,CAAC4I,SAAA,EAAW,GAAGT,IAAA,CAAInI,OAAO;QAC1C;MACF;MACA2P,eAAexH,IAAA,EAAK;QAClB0F,IAAA,CAAK1F,IAAA,EAAK,CAACtK,KAAA,EAAOqD,KAAA,EAAOvD,MAAA,KAAW;UAGlCE,KAAA,CAAMC,KAAA,CAAMC,OAAA,CAAQmD,KAAA,GAAQA,KAAA;UAC5BrD,KAAA,CAAMC,KAAA,CAAMC,OAAA,CAAQ6C,SAAA,GAAYM,KAAA,KAAU;UAC1CrD,KAAA,CAAMC,KAAA,CAAMC,OAAA,CAAQmC,MAAA,GAASvC,MAAA,CAAO2E,MAAA,GAASpB,KAAA;QAC/C,CAAC;MACH;MACA0O,gBAAgBzH,IAAA,EAAKuB,GAAA,EAAK;QACxB,MAAM3M,SAAA,GAAY2M,GAAA,CAAI3M,SAAA,IAAaoL,IAAA,CAAIpL,SAAA;QAGvC8Q,IAAA,CAAK;UAAE,GAAG1F,IAAA;UAAKpL;QAAU,GAAIc,KAAA,IAAU;UACrC,MAAMgS,WAAA,GAAcC,IAAA,CAAK9E,GAAA,CACvB7C,IAAA,CAAInI,OAAA,CAAQ+P,SAAA,CAAW9P,MAAA,IAAWA,MAAA,CAAO7C,EAAA,KAAOS,KAAA,CAAMT,EAAE,GACxD,CACF;UAGA,MAAM4S,kBAAA,GAAqB7H,IAAA,CAAInI,OAAA,CAAQiQ,MAAA,CAAO,CAACC,IAAA,EAAMC,IAAA,EAAMC,YAAA,KAAiB;YAC1E,IAAIA,YAAA,IAAgBP,WAAA,EAAa,OAAOK,IAAA;YACxC,OAAOA,IAAA,GAAOC,IAAA,CAAKlQ,MAAA;UACrB,GAAG,CAAC;UAIJpC,KAAA,CAAMC,KAAA,CAAMC,OAAA,CAAQY,MAAA,GAASkR,WAAA,GAAc1H,IAAA,CAAIpI,GAAA,GAAMiQ,kBAAA;QACvD,CAAC;MACH;MACAK,iBAAiBlI,IAAA,EAAKuB,GAAA,EAAK;QACzB,IAAIvB,IAAA,CAAI5C,aAAA,IAAiB,CAACmE,GAAA,CAAItE,MAAA,EAAQ;QACtC+C,IAAA,CAAI5C,aAAA,GAAgB;QACpB4C,IAAA,CAAI+C,aAAA,GAAgBrF,GAAA,CAAI6D,GAAA,CAAItE,MAAM;MACpC;MACAkL,qBAAqBnI,IAAA,EAAK;QACxBA,IAAA,CAAI5C,aAAA,GAAgB;QACpB,IAAI,CAAC4C,IAAA,CAAI+C,aAAA,EAAe;QACxB/C,IAAA,CAAI+C,aAAA,CAAcyC,KAAA,CAAM;UAAE4C,aAAA,EAAe;QAAK,CAAC;QAC/CpI,IAAA,CAAI+C,aAAA,GAAgB;MACtB;MACAsF,mBAAmBrI,IAAA,EAAK;QACtB,IAAI,CAACA,IAAA,CAAI+C,aAAA,EAAe;QACxB/C,IAAA,CAAI+C,aAAA,CAAcyC,KAAA,CAAM;UAAE4C,aAAA,EAAe;QAAK,CAAC;QAC/CpI,IAAA,CAAI+C,aAAA,GAAgB;QACpB/C,IAAA,CAAI5C,aAAA,GAAgB;MACtB;IACF;EACF,CACF;AACF;AAEA,SAASsI,KAAK5Q,GAAA,EAA0BwI,EAAA,EAAuE;EAC7G,MAAM0H,aAAA,GAAgBzP,oBAAA,CAAqBT,GAAA,CAAIU,MAAA,EAAQV,GAAA,CAAIF,SAAS;EACpEoQ,aAAA,CAAc5J,OAAA,CAAQkC,EAAE;AAC1B;;;AEhUA,SAASgL,QAAA,QAAgB;AAOlB,SAASC,QACd5S,KAAA,EACAkE,IAAA,EACAC,SAAA,EACkB;EAClB,MAAMzB,OAAA,GAAU1C,KAAA,CAAM6S,MAAA,CAAO,SAAS;EACtC,MAAMC,MAAA,GAAS9S,KAAA,CAAM6S,MAAA,CAAO,QAAQ;EAEpC,MAAM5T,SAAA,GAAYe,KAAA,CAAMC,OAAA,CAAQhB,SAAA;EAChC,MAAM0B,IAAA,GAAOX,KAAA,CAAMC,OAAA,CAAQU,IAAA;EAE3B,MAAM,CAACgC,IAAA,EAAMgE,KAAA,GAAQ,QAAQ,IAAI1H,SAAA,CAAU2D,KAAA,CAAM,GAAG;EAEpD,OAAO;IACLjC,IAAA;IACAoS,KAAA,EAAO/S,KAAA,CAAMC,OAAA,CAAQ8S,KAAA;IACrBC,WAAA,EAAahT,KAAA,CAAMC,OAAA,CAAQ+S,WAAA;IAC3B/T,SAAA;IACAyD,OAAA;IACAoQ,MAAA;IAEA1M,MAAA,EAAQ;MACNlC,IAAA,CAAK,OAAO;IACd;IAEAmC,OAAA,EAAS;MACPnC,IAAA,CAAK,QAAQ;IACf;IAEAa,QAAA,EAAU;MACRb,IAAA,CAAK,SAAS;IAChB;IAEA+O,aAAA,EAAe;MACb,OAAO9O,SAAA,CAAUyC,OAAA,CAAQ;QACvB,GAAGhI,KAAA,CAAMsU,IAAA,CAAKpM,KAAA;QACdzF,GAAA,EAAKrB,KAAA,CAAMC,OAAA,CAAQoB,GAAA;QACnB/B,EAAA,EAAIP,GAAA,CAAIM,SAAA,CAAUW,KAAA,CAAMC,OAAO;QAC/B,cAAcyC,OAAA,GAAU,SAAS;QACjC,aAAa/B,IAAA;QACb,kBAAkB1B,SAAA;QAClB,cAAc0H,KAAA;QACd,aAAahE,IAAA;QACb,gBAAgBgQ,QAAA,CAAS3S,KAAA,CAAMC,OAAA,CAAQuD,OAAO;QAC9C,eAAemP,QAAA,CAASG,MAAM;QAE9B,cAAcH,QAAA,CAAS3S,KAAA,CAAMC,OAAA,CAAQ6C,SAAS;QAC9C,gBAAgB6P,QAAA,CAAS,CAAC3S,KAAA,CAAMC,OAAA,CAAQ6C,SAAS;QACjD,cAAc6P,QAAA,CAAS3S,KAAA,CAAMC,OAAA,CAAQ+C,OAAO;QAC5C,gBAAgB2P,QAAA,CAAS,CAAC3S,KAAA,CAAMC,OAAA,CAAQ+C,OAAO;QAE/CgE,IAAA,EAAM;QACN,eAAe;QACf,oBAAoBhH,KAAA,CAAMC,OAAA,CAAQ+S,WAAA,GAAcjU,GAAA,CAAIU,gBAAA,CAAiBO,KAAA,CAAMC,OAAO,IAAI;QACtF,mBAAmBD,KAAA,CAAMC,OAAA,CAAQ8S,KAAA,GAAQhU,GAAA,CAAIS,UAAA,CAAWQ,KAAA,CAAMC,OAAO,IAAI;QACzE8G,QAAA,EAAU;QACVE,KAAA,EAAOxE,iBAAA,CAAkBzC,KAAA,CAAMC,OAAA,EAASyC,OAAO;QAC/CyQ,UAAU9L,KAAA,EAAO;UACf,IAAIA,KAAA,CAAM+L,gBAAA,EAAkB;UAC5B,IAAI/L,KAAA,CAAMsH,GAAA,IAAO,UAAU;YACzBzK,IAAA,CAAK,SAAS;YACdmD,KAAA,CAAMgM,cAAA,CAAe;UACvB;QACF;MACF,CAAC;IACH;IAAA;IAGAC,oBAAA,EAAsB;MACpB,OAAOnP,SAAA,CAAUyC,OAAA,CAAQ;QACvB,cAAc;QACdK,KAAA,EAAOxD,mBAAA,CAAoBzD,KAAA,CAAMC,OAAA,EAASyC,OAAO;MACnD,CAAC;IACH;IAAA;IAGA6Q,mBAAA,EAAqB;MACnB,OAAOpP,SAAA,CAAUyC,OAAA,CAAQ;QACvB,cAAc;QACdK,KAAA,EAAOrD,kBAAA,CAAmB5D,KAAA,CAAMC,OAAA,EAASyC,OAAO;MAClD,CAAC;IACH;IAEA8Q,cAAA,EAAgB;MACd,OAAOrP,SAAA,CAAUyC,OAAA,CAAQ;QACvB,GAAGhI,KAAA,CAAMmU,KAAA,CAAMjM,KAAA;QACfxH,EAAA,EAAIP,GAAA,CAAIS,UAAA,CAAWQ,KAAA,CAAMC,OAAO;MAClC,CAAC;IACH;IAEAwT,oBAAA,EAAsB;MACpB,OAAOtP,SAAA,CAAUyC,OAAA,CAAQ;QACvB,GAAGhI,KAAA,CAAMoU,WAAA,CAAYlM,KAAA;QACrBxH,EAAA,EAAIP,GAAA,CAAIU,gBAAA,CAAiBO,KAAA,CAAMC,OAAO;MACxC,CAAC;IACH;IAEAyT,sBAAA,EAAwB;MACtB,OAAOvP,SAAA,CAAUwP,MAAA,CAAO;QACtB,GAAG/U,KAAA,CAAMgV,aAAA,CAAc9M,KAAA;QACvBnG,IAAA,EAAM;QACNkT,QAAQxM,KAAA,EAAO;UACb,IAAIA,KAAA,CAAM+L,gBAAA,EAAkB;UAC5BlP,IAAA,CAAK,SAAS;QAChB;MACF,CAAC;IACH;IAEA4P,qBAAA,EAAuB;MACrB,OAAO3P,SAAA,CAAUwP,MAAA,CAAO;QACtBrU,EAAA,EAAIP,GAAA,CAAIW,iBAAA,CAAkBM,KAAA,CAAMC,OAAO;QACvC,GAAGrB,KAAA,CAAMmV,YAAA,CAAajN,KAAA;QACtBnG,IAAA,EAAM;QACN,cAAc;QACdkT,QAAQxM,KAAA,EAAO;UACb,IAAIA,KAAA,CAAM+L,gBAAA,EAAkB;UAC5BlP,IAAA,CAAK,SAAS;QAChB;MACF,CAAC;IACH;EACF;AACF;;;ACvGO,IAAM2C,KAAA,GAAQ;EACnB+L,OAAA,EAAS5O,YAAA;EACTgQ,OAAA,EAAShH;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}