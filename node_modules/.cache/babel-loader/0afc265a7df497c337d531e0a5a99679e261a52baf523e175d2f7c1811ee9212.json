{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/index.ts\nimport { proxy as proxy2, ref as ref2, snapshot as snapshot2, subscribe as subscribe2 } from \"@zag-js/store\";\n\n// ../utilities/core/src/array.ts\nfunction clear(v) {\n  while (v.length > 0) v.pop();\n  return v;\n}\n\n// ../utilities/core/src/functions.ts\nvar runIfFn = function (v) {\n  for (var _len = arguments.length, a = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    a[_key - 1] = arguments[_key];\n  }\n  const res = typeof v === \"function\" ? v(...a) : v;\n  return res ?? void 0;\n};\nvar cast = v => v;\nvar noop = () => {};\nvar callAll = function () {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n  return function () {\n    for (var _len3 = arguments.length, a = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      a[_key3] = arguments[_key3];\n    }\n    fns.forEach(function (fn) {\n      fn?.(...a);\n    });\n  };\n};\nvar uuid = /* @__PURE__ */(() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(36);\n  };\n})();\n\n// ../utilities/core/src/guard.ts\nvar isDev = () => process.env.NODE_ENV !== \"production\";\nvar isArray = v => Array.isArray(v);\nvar isObject = v => !(v == null || typeof v !== \"object\" || isArray(v));\nvar isNumber = v => typeof v === \"number\" && !Number.isNaN(v);\nvar isString = v => typeof v === \"string\";\nvar isFunction = v => typeof v === \"function\";\nvar hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\n// ../utilities/core/src/object.ts\nfunction compact(obj) {\n  if (!isPlainObject(obj) || obj === void 0) {\n    return obj;\n  }\n  const keys = Reflect.ownKeys(obj).filter(key => typeof key === \"string\");\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = compact(value);\n    }\n  }\n  return filtered;\n}\nvar isPlainObject = value => {\n  return value && typeof value === \"object\" && value.constructor === Object;\n};\n\n// ../utilities/core/src/warning.ts\nfunction warn() {\n  const m = arguments.length === 1 ? arguments.length <= 0 ? undefined : arguments[0] : arguments.length <= 1 ? undefined : arguments[1];\n  const c = arguments.length === 2 ? arguments.length <= 0 ? undefined : arguments[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m);\n  }\n}\nfunction invariant() {\n  const m = arguments.length === 1 ? arguments.length <= 0 ? undefined : arguments[0] : arguments.length <= 1 ? undefined : arguments[1];\n  const c = arguments.length === 2 ? arguments.length <= 0 ? undefined : arguments[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m);\n  }\n}\n\n// src/deep-merge.ts\nfunction deepMerge(source) {\n  for (var _len4 = arguments.length, objects = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    objects[_key4 - 1] = arguments[_key4];\n  }\n  for (const obj of objects) {\n    const target = compact(obj);\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {};\n        }\n        deepMerge(source[key], obj[key]);\n      } else {\n        source[key] = obj[key];\n      }\n    }\n  }\n  return source;\n}\n\n// src/utils.ts\nimport { klona } from \"klona/full\";\nfunction structuredClone(v) {\n  return klona(v);\n}\nfunction toEvent(event) {\n  const obj = isString(event) ? {\n    type: event\n  } : event;\n  return obj;\n}\nfunction toArray(value) {\n  if (!value) return [];\n  return isArray(value) ? value.slice() : [value];\n}\nfunction isGuardHelper(value) {\n  return isObject(value) && value.predicate != null;\n}\n\n// src/guard-utils.ts\nvar Truthy = () => true;\nfunction exec(guardMap, ctx, event, meta) {\n  return guard => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta);\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta);\n    }\n    return guard.predicate(guardMap)(ctx, event, meta);\n  };\n}\nfunction or() {\n  for (var _len5 = arguments.length, conditions = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    conditions[_key5] = arguments[_key5];\n  }\n  return {\n    predicate: guardMap => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)\n  };\n}\nfunction and() {\n  for (var _len6 = arguments.length, conditions = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    conditions[_key6] = arguments[_key6];\n  }\n  return {\n    predicate: guardMap => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)\n  };\n}\nfunction not(condition) {\n  return {\n    predicate: guardMap => (ctx, event, meta) => {\n      return !exec(guardMap, ctx, event, meta)(condition);\n    }\n  };\n}\nfunction stateIn() {\n  for (var _len7 = arguments.length, values = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    values[_key7] = arguments[_key7];\n  }\n  return (_ctx, _evt, meta) => meta.state.matches(...values);\n}\nvar guards = {\n  or,\n  and,\n  not,\n  stateIn\n};\nfunction choose(actions) {\n  return {\n    predicate: guardMap => (ctx, event, meta) => actions.find(def => {\n      const guard = def.guard ?? Truthy;\n      return exec(guardMap, ctx, event, meta)(guard);\n    })?.actions\n  };\n}\nfunction determineGuardFn(guard, guardMap) {\n  guard = guard ?? Truthy;\n  return (context, event, meta) => {\n    if (isString(guard)) {\n      const value = guardMap[guard];\n      return isFunction(value) ? value(context, event, meta) : value;\n    }\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta);\n    }\n    return guard?.(context, event, meta);\n  };\n}\nfunction determineActionsFn(values, guardMap) {\n  return (context, event, meta) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta);\n    }\n    return values;\n  };\n}\n\n// src/machine.ts\nimport { ref, snapshot, subscribe } from \"@zag-js/store\";\n\n// src/create-proxy.ts\nimport { proxy, proxyWithComputed } from \"@zag-js/store\";\nfunction createProxy(config) {\n  const computedContext = config.computed ?? cast({});\n  const initialContext = config.context ?? cast({});\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : [];\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast({}),\n    previousEvent: cast({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: initialTags ?? [],\n    hasTag(tag) {\n      return this.tags.includes(tag);\n    },\n    matches() {\n      for (var _len8 = arguments.length, value = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        value[_key8] = arguments[_key8];\n      }\n      return value.includes(this.value);\n    },\n    can(event) {\n      return cast(this).nextEvents.includes(event);\n    },\n    get nextEvents() {\n      const stateEvents = config.states?.[this.value]?.[\"on\"] ?? {};\n      const globalEvents = config?.on ?? {};\n      return Object.keys({\n        ...stateEvents,\n        ...globalEvents\n      });\n    },\n    get changed() {\n      if (this.event.value === \"machine.init\" /* Init */ || !this.previousValue) return false;\n      return this.value !== this.previousValue;\n    }\n  });\n  return cast(state);\n}\n\n// src/delay-utils.ts\nfunction determineDelayFn(delay, delaysMap) {\n  return (context, event) => {\n    if (isNumber(delay)) return delay;\n    if (isFunction(delay)) {\n      return delay(context, event);\n    }\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay);\n      if (!Number.isNaN(value)) {\n        return value;\n      }\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay];\n        invariant(valueOrFn == null, `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``);\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn;\n      }\n    }\n  };\n}\n\n// src/transition-utils.ts\nfunction toTarget(target) {\n  return isString(target) ? {\n    target\n  } : target;\n}\nfunction determineTransitionFn(transitions, guardMap) {\n  return (context, event, meta) => {\n    return toArray(transitions).map(toTarget).find(transition => {\n      const determineGuard = determineGuardFn(transition.guard, guardMap);\n      const guard = determineGuard(context, event, meta);\n      return guard ?? transition.target ?? transition.actions;\n    });\n  };\n}\n\n// src/machine.ts\nvar Machine = class {\n  // Let's get started!\n  constructor(config, options) {\n    var _this = this;\n    __publicField(this, \"status\", \"Not Started\" /* NotStarted */);\n    __publicField(this, \"state\");\n    __publicField(this, \"initialState\");\n    __publicField(this, \"initialContext\");\n    __publicField(this, \"id\");\n    __publicField(this, \"type\", \"machine\" /* Machine */);\n    // Cleanup function map (per state)\n    __publicField(this, \"activityEvents\", /* @__PURE__ */new Map());\n    __publicField(this, \"delayedEvents\", /* @__PURE__ */new Map());\n    // state update listeners the user can opt-in for\n    __publicField(this, \"stateListeners\", /* @__PURE__ */new Set());\n    __publicField(this, \"doneListeners\", /* @__PURE__ */new Set());\n    __publicField(this, \"contextWatchers\", /* @__PURE__ */new Set());\n    // Cleanup functions (for `subscribe`)\n    __publicField(this, \"removeStateListener\", noop);\n    // For Parent <==> Spawned Actor relationship\n    __publicField(this, \"parent\");\n    __publicField(this, \"children\", /* @__PURE__ */new Map());\n    // A map of guard, action, delay implementations\n    __publicField(this, \"guardMap\");\n    __publicField(this, \"actionMap\");\n    __publicField(this, \"delayMap\");\n    __publicField(this, \"activityMap\");\n    __publicField(this, \"sync\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"_created\", () => {\n      const event = toEvent(\"machine.created\" /* Created */);\n      this.executeActions(this.config?.created, event);\n    });\n    // Starts the interpreted machine.\n    __publicField(this, \"start\", init => {\n      this.state.value = \"\";\n      this.state.tags = [];\n      if (this.status === \"Running\" /* Running */) {\n        return this;\n      }\n      this.status = \"Running\" /* Running */;\n      this.removeStateListener = subscribe(this.state, () => {\n        this.stateListeners.forEach(listener => {\n          listener(this.stateSnapshot);\n        });\n      }, this.sync);\n      this.setupContextWatchers();\n      this.executeActivities(toEvent(\"machine.start\" /* Start */), toArray(this.config.activities), \"machine.start\" /* Start */);\n      this.executeActions(this.config.entry, toEvent(\"machine.start\" /* Start */));\n      const event = toEvent(\"machine.init\" /* Init */);\n      const target = isObject(init) ? init.value : init;\n      const context = isObject(init) ? init.context : void 0;\n      if (context) {\n        this.setContext(context);\n      }\n      const transition = {\n        target: target ?? this.config.initial\n      };\n      const next = this.getNextStateInfo(transition, event);\n      this.initialState = next;\n      this.performStateChangeEffects(this.state.value, next, event);\n      return this;\n    });\n    __publicField(this, \"setupContextWatchers\", () => {\n      const {\n        watch\n      } = this.config;\n      if (!watch) return;\n      let prev = snapshot(this.state.context);\n      const cleanup = subscribe(this.state.context, () => {\n        const next = snapshot(this.state.context);\n        for (const [key, fn] of Object.entries(watch)) {\n          const isEqual = this.options.compareFns?.[key] ?? Object.is;\n          if (isEqual(prev[key], next[key])) continue;\n          this.executeActions(fn, this.state.event);\n        }\n        prev = next;\n      });\n      this.contextWatchers.add(cleanup);\n    });\n    // Stops the interpreted machine\n    __publicField(this, \"stop\", () => {\n      if (this.status === \"Stopped\" /* Stopped */) return;\n      this.performExitEffects(this.state.value, toEvent(\"machine.stop\" /* Stop */));\n      this.executeActions(this.config.exit, toEvent(\"machine.stop\" /* Stop */));\n      this.setState(\"\");\n      this.setEvent(\"machine.stop\" /* Stop */);\n      this.stopStateListeners();\n      this.stopChildren();\n      this.stopActivities();\n      this.stopDelayedEvents();\n      this.stopContextWatchers();\n      this.status = \"Stopped\" /* Stopped */;\n      return this;\n    });\n    __publicField(this, \"stopStateListeners\", () => {\n      this.removeStateListener();\n      this.stateListeners.clear();\n    });\n    __publicField(this, \"stopContextWatchers\", () => {\n      this.contextWatchers.forEach(fn => fn());\n      this.contextWatchers.clear();\n    });\n    __publicField(this, \"stopDelayedEvents\", () => {\n      this.delayedEvents.forEach(state => {\n        state.forEach(stop => stop());\n      });\n      this.delayedEvents.clear();\n    });\n    // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n    __publicField(this, \"stopActivities\", state => {\n      if (state) {\n        this.activityEvents.get(state)?.forEach(stop => stop());\n        this.activityEvents.get(state)?.clear();\n        this.activityEvents.delete(state);\n      } else {\n        this.activityEvents.forEach(state2 => {\n          state2.forEach(stop => stop());\n          state2.clear();\n        });\n        this.activityEvents.clear();\n      }\n    });\n    /**\n     * Function to send event to spawned child machine or actor\n     */\n    __publicField(this, \"sendChild\", (evt, to) => {\n      const event = toEvent(evt);\n      const id = runIfFn(to, this.contextSnapshot);\n      const child = this.children.get(id);\n      if (!child) {\n        invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);\n      }\n      child.send(event);\n    });\n    /**\n     * Function to stop a running child machine or actor\n     */\n    __publicField(this, \"stopChild\", id => {\n      if (!this.children.has(id)) {\n        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);\n      }\n      this.children.get(id).stop();\n      this.children.delete(id);\n    });\n    __publicField(this, \"removeChild\", id => {\n      this.children.delete(id);\n    });\n    // Stop and delete spawned actors\n    __publicField(this, \"stopChildren\", () => {\n      this.children.forEach(child => child.stop());\n      this.children.clear();\n    });\n    __publicField(this, \"setParent\", parent => {\n      this.parent = parent;\n    });\n    __publicField(this, \"spawn\", (src, id) => {\n      const actor = runIfFn(src);\n      if (id) actor.id = id;\n      actor.type = \"machine.actor\" /* Actor */;\n      actor.setParent(this);\n      this.children.set(actor.id, cast(actor));\n      actor.onDone(() => {\n        this.removeChild(actor.id);\n      }).start();\n      return cast(ref(actor));\n    });\n    __publicField(this, \"stopActivity\", key => {\n      if (!this.state.value) return;\n      const cleanups = this.activityEvents.get(this.state.value);\n      cleanups?.get(key)?.();\n      cleanups?.delete(key);\n    });\n    __publicField(this, \"addActivityCleanup\", (state, key, cleanup) => {\n      if (!state) return;\n      if (!this.activityEvents.has(state)) {\n        this.activityEvents.set(state, /* @__PURE__ */new Map([[key, cleanup]]));\n      } else {\n        this.activityEvents.get(state)?.set(key, cleanup);\n      }\n    });\n    __publicField(this, \"setState\", target => {\n      this.state.previousValue = this.state.value;\n      this.state.value = target;\n      const stateNode = this.getStateNode(target);\n      if (target == null) {\n        clear(this.state.tags);\n      } else {\n        this.state.tags = toArray(stateNode?.tags);\n      }\n    });\n    /**\n     * To used within side effects for React or Vue to update context\n     */\n    __publicField(this, \"setContext\", context => {\n      if (!context) return;\n      deepMerge(this.state.context, compact(context));\n    });\n    __publicField(this, \"setOptions\", options => {\n      const opts = compact(options);\n      this.actionMap = {\n        ...this.actionMap,\n        ...opts.actions\n      };\n      this.delayMap = {\n        ...this.delayMap,\n        ...opts.delays\n      };\n      this.activityMap = {\n        ...this.activityMap,\n        ...opts.activities\n      };\n      this.guardMap = {\n        ...this.guardMap,\n        ...opts.guards\n      };\n    });\n    __publicField(this, \"getStateNode\", state => {\n      if (!state) return;\n      return this.config.states?.[state];\n    });\n    __publicField(this, \"getNextStateInfo\", (transitions, event) => {\n      const transition = this.determineTransition(transitions, event);\n      const isTargetless = !transition?.target;\n      const target = transition?.target ?? this.state.value;\n      const changed = this.state.value !== target;\n      const stateNode = this.getStateNode(target);\n      const reenter = !isTargetless && !changed && !transition?.internal;\n      const info = {\n        reenter,\n        transition,\n        stateNode,\n        target,\n        changed\n      };\n      this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target);\n      return info;\n    });\n    __publicField(this, \"getAfterActions\", (transition, delay) => {\n      let id;\n      return {\n        entry: () => {\n          id = globalThis.setTimeout(() => {\n            const next = this.getNextStateInfo(transition, this.state.event);\n            this.performStateChangeEffects(this.state.value, next, this.state.event);\n          }, delay);\n        },\n        exit: () => {\n          globalThis.clearTimeout(id);\n        }\n      };\n    });\n    /**\n     * All `after` events leverage `setTimeout` and `clearTimeout`,\n     * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n     *\n     * To achieve this, we split the `after` defintion into `entry` and `exit`\n     *  functions and append them to the state's `entry` and `exit` actions\n     */\n    __publicField(this, \"getDelayedEventActions\", state => {\n      const stateNode = this.getStateNode(state);\n      const event = this.state.event;\n      if (!stateNode || !stateNode.after) return;\n      const entries = [];\n      const exits = [];\n      if (isArray(stateNode.after)) {\n        const transition = this.determineTransition(stateNode.after, event);\n        if (!transition) return;\n        if (!hasProp(transition, \"delay\")) {\n          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);\n        }\n        const determineDelay = determineDelayFn(transition.delay, this.delayMap);\n        const __delay = determineDelay(this.contextSnapshot, event);\n        const actions = this.getAfterActions(transition, __delay);\n        entries.push(actions.entry);\n        exits.push(actions.exit);\n        return {\n          entries,\n          exits\n        };\n      }\n      if (isObject(stateNode.after)) {\n        for (const delay in stateNode.after) {\n          const transition = stateNode.after[delay];\n          const determineDelay = determineDelayFn(delay, this.delayMap);\n          const __delay = determineDelay(this.contextSnapshot, event);\n          const actions = this.getAfterActions(transition, __delay);\n          entries.push(actions.entry);\n          exits.push(actions.exit);\n        }\n      }\n      return {\n        entries,\n        exits\n      };\n    });\n    /**\n     * Function to executes defined actions. It can accept actions as string\n     * (referencing `options.actions`) or actual functions.\n     */\n    __publicField(this, \"executeActions\", (actions, event) => {\n      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      for (const action of toArray(pickedActions)) {\n        const fn = isString(action) ? this.actionMap?.[action] : action;\n        warn(isString(action) && !fn, `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``);\n        fn?.(this.state.context, event, this.meta);\n      }\n    });\n    /**\n     * Function to execute running activities and registers\n     * their cleanup function internally (to be called later on when we exit the state)\n     */\n    __publicField(this, \"executeActivities\", (event, activities, state) => {\n      for (const activity of activities) {\n        const fn = isString(activity) ? this.activityMap?.[activity] : activity;\n        if (!fn) {\n          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``);\n          continue;\n        }\n        const cleanup = fn(this.state.context, event, this.meta);\n        if (cleanup) {\n          const key = isString(activity) ? activity : activity.name || uuid();\n          this.addActivityCleanup(state ?? this.state.value, key, cleanup);\n        }\n      }\n    });\n    /**\n     * Normalizes the `every` definition to transition. `every` can be:\n     * - An array of possible actions to run (we need to pick the first match based on guard)\n     * - An object of intervals and actions\n     */\n    __publicField(this, \"createEveryActivities\", (every, callbackfn) => {\n      if (!every) return;\n      if (isArray(every)) {\n        const picked = toArray(every).find(transition => {\n          const delayOrFn = transition.delay;\n          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);\n          const delay2 = determineDelay2(this.contextSnapshot, this.state.event);\n          const determineGuard = determineGuardFn(transition.guard, this.guardMap);\n          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);\n          return guard ?? delay2 != null;\n        });\n        if (!picked) return;\n        const determineDelay = determineDelayFn(picked.delay, this.delayMap);\n        const delay = determineDelay(this.contextSnapshot, this.state.event);\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(picked.actions, this.state.event);\n          }, delay);\n          return () => {\n            globalThis.clearInterval(id);\n          };\n        };\n        callbackfn(activity);\n      } else {\n        for (const interval in every) {\n          const actions = every?.[interval];\n          const determineDelay = determineDelayFn(interval, this.delayMap);\n          const delay = determineDelay(this.contextSnapshot, this.state.event);\n          const activity = () => {\n            const id = globalThis.setInterval(() => {\n              this.executeActions(actions, this.state.event);\n            }, delay);\n            return () => {\n              globalThis.clearInterval(id);\n            };\n          };\n          callbackfn(activity);\n        }\n      }\n    });\n    __publicField(this, \"setEvent\", event => {\n      this.state.previousEvent = this.state.event;\n      this.state.event = ref(toEvent(event));\n    });\n    __publicField(this, \"performExitEffects\", (current, event) => {\n      const currentState = this.state.value;\n      if (currentState === \"\") return;\n      const stateNode = current ? this.getStateNode(current) : void 0;\n      this.stopActivities(currentState);\n      const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      const exitActions = toArray(_exit);\n      const afterExitActions = this.delayedEvents.get(currentState);\n      if (afterExitActions) {\n        exitActions.push(...afterExitActions);\n      }\n      this.executeActions(exitActions, event);\n    });\n    __publicField(this, \"performEntryEffects\", (next, event) => {\n      const stateNode = this.getStateNode(next);\n      const activities = toArray(stateNode?.activities);\n      this.createEveryActivities(stateNode?.every, activity => {\n        activities.unshift(activity);\n      });\n      if (activities.length > 0) {\n        this.executeActivities(event, activities);\n      }\n      const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      const entryActions = toArray(pickedActions);\n      const afterActions = this.getDelayedEventActions(next);\n      if (stateNode?.after && afterActions) {\n        this.delayedEvents.set(next, afterActions?.exits);\n        entryActions.push(...afterActions.entries);\n      }\n      this.executeActions(entryActions, event);\n      if (stateNode?.type === \"final\") {\n        this.state.done = true;\n        this.doneListeners.forEach(listener => {\n          listener(this.stateSnapshot);\n        });\n        this.stop();\n      }\n    });\n    __publicField(this, \"performTransitionEffects\", (transitions, event) => {\n      const transition = this.determineTransition(transitions, event);\n      this.executeActions(transition?.actions, event);\n    });\n    /**\n     * Performs all the requires side-effects or reactions when\n     * we move from state A => state B.\n     *\n     * The Effect order:\n     * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n     */\n    __publicField(this, \"performStateChangeEffects\", (current, next, event) => {\n      this.setEvent(event);\n      const changed = next.changed || next.reenter;\n      if (changed) {\n        this.performExitEffects(current, event);\n      }\n      this.performTransitionEffects(next.transition, event);\n      this.setState(next.target);\n      if (changed) {\n        this.performEntryEffects(next.target, event);\n      }\n    });\n    __publicField(this, \"determineTransition\", (transition, event) => {\n      const fn = determineTransitionFn(transition, this.guardMap);\n      return fn?.(this.contextSnapshot, event, this.guardMeta);\n    });\n    /**\n     * Function to send event to parent machine from spawned child\n     */\n    __publicField(this, \"sendParent\", evt => {\n      if (!this.parent) {\n        invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\");\n      }\n      const event = toEvent(evt);\n      this.parent?.send(event);\n    });\n    __publicField(this, \"log\", function () {\n      if (isDev() && _this.options.debug) {\n        console.log(...arguments);\n      }\n    });\n    /**\n     * Function to send an event to current machine\n     */\n    __publicField(this, \"send\", evt => {\n      const event = toEvent(evt);\n      this.transition(this.state.value, event);\n    });\n    __publicField(this, \"transition\", (state, evt) => {\n      const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode;\n      const event = toEvent(evt);\n      if (!stateNode && !this.config.on) {\n        const msg = this.status === \"Stopped\" /* Stopped */ ? \"[@zag-js/core > transition] Cannot transition a stopped machine\" : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`;\n        warn(msg);\n        return;\n      }\n      const transitions =\n      // @ts-expect-error - Fix this\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type];\n      const next = this.getNextStateInfo(transitions, event);\n      this.performStateChangeEffects(this.state.value, next, event);\n      return next.stateNode;\n    });\n    __publicField(this, \"subscribe\", listener => {\n      this.stateListeners.add(listener);\n      if (this.status === \"Running\" /* Running */) {\n        listener(this.stateSnapshot);\n      }\n      return () => {\n        this.stateListeners.delete(listener);\n      };\n    });\n    __publicField(this, \"onDone\", listener => {\n      this.doneListeners.add(listener);\n      return this;\n    });\n    __publicField(this, \"onTransition\", listener => {\n      this.stateListeners.add(listener);\n      if (this.status === \"Running\" /* Running */) {\n        listener(this.stateSnapshot);\n      }\n      return this;\n    });\n    this.config = structuredClone(config);\n    this.options = structuredClone(options ?? {});\n    this.id = this.config.id ?? `machine-${uuid()}`;\n    this.guardMap = this.options?.guards ?? {};\n    this.actionMap = this.options?.actions ?? {};\n    this.delayMap = this.options?.delays ?? {};\n    this.activityMap = this.options?.activities ?? {};\n    this.sync = this.options?.sync ?? false;\n    this.state = createProxy(this.config);\n    this.initialContext = snapshot(this.state.context);\n  }\n  // immutable state value\n  get stateSnapshot() {\n    return cast(snapshot(this.state));\n  }\n  getState() {\n    return this.stateSnapshot;\n  }\n  // immutable context value\n  get contextSnapshot() {\n    return this.stateSnapshot.context;\n  }\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  get self() {\n    const self = this;\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this),\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot;\n      },\n      get initialContext() {\n        return self.initialContext;\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\";\n      }\n    };\n  }\n  get meta() {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: key => this.actionMap[key],\n      getGuard: key => this.guardMap[key]\n    };\n  }\n  get guardMeta() {\n    return {\n      state: this.stateSnapshot\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return \"Machine\";\n  }\n  getHydrationState() {\n    const state = this.getState();\n    return {\n      value: state.value,\n      tags: state.tags\n    };\n  }\n};\nvar createMachine = (config, options) => new Machine(config, options);\nvar isMachine = value => {\n  return value instanceof Machine || value?.type === \"machine\" /* Machine */;\n};\n\n// src/merge-props.ts\nvar clsx = function () {\n  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    args[_key9] = arguments[_key9];\n  }\n  return args.map(str => str?.trim?.()).filter(Boolean).join(\" \");\n};\nvar CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g;\nvar serialize = style => {\n  const res = {};\n  let match;\n  while (match = CSS_REGEX.exec(style)) {\n    res[match[1]] = match[2];\n  }\n  return res;\n};\nvar css = (a, b) => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`;\n    a = serialize(a);\n  } else if (isString(b)) {\n    b = serialize(b);\n  }\n  return Object.assign({}, a ?? {}, b ?? {});\n};\nfunction mergeProps() {\n  let result = {};\n  for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    args[_key10] = arguments[_key10];\n  }\n  for (let props of args) {\n    for (let key in result) {\n      if (key.startsWith(\"on\") && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key]);\n        continue;\n      }\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key]);\n        continue;\n      }\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key]);\n        continue;\n      }\n      result[key] = props[key] !== void 0 ? props[key] : result[key];\n    }\n    for (let key in props) {\n      if (result[key] === void 0) {\n        result[key] = props[key];\n      }\n    }\n  }\n  return result;\n}\nexport { Machine, choose, createMachine, deepMerge, guards, isMachine, mergeProps, proxy2 as proxy, ref2 as ref, snapshot2 as snapshot, subscribe2 as subscribe };","map":{"version":3,"names":["proxy","proxy2","ref","ref2","snapshot","snapshot2","subscribe","subscribe2","clear","v","length","pop","runIfFn","_len","arguments","a","Array","_key","res","cast","noop","callAll","_len2","fns","_key2","_len3","_key3","forEach","fn","uuid","id","toString","isDev","process","env","NODE_ENV","isArray","isObject","isNumber","Number","isNaN","isString","isFunction","hasProp","obj","prop","Object","prototype","hasOwnProperty","call","compact","isPlainObject","keys","Reflect","ownKeys","filter","key","filtered","value","constructor","warn","m","undefined","c","console","invariant","Error","deepMerge","source","_len4","objects","_key4","target","klona","structuredClone","toEvent","event","type","toArray","slice","isGuardHelper","predicate","Truthy","exec","guardMap","ctx","meta","guard","or","_len5","conditions","_key5","map","some","Boolean","and","_len6","_key6","every","not","condition","stateIn","_len7","values","_key7","_ctx","_evt","state","matches","guards","choose","actions","find","def","determineGuardFn","context","determineActionsFn","proxyWithComputed","createProxy","config","computedContext","computed","initialContext","initialTags","initial","states","tags","previousValue","previousEvent","done","hasTag","tag","includes","_len8","_key8","can","nextEvents","stateEvents","globalEvents","on","changed","determineDelayFn","delay","delaysMap","parseFloat","valueOrFn","toTarget","determineTransitionFn","transitions","transition","determineGuard","Machine","options","_this","__publicField","Map","Set","executeActions","created","init","status","removeStateListener","stateListeners","listener","stateSnapshot","sync","setupContextWatchers","executeActivities","activities","entry","setContext","next","getNextStateInfo","initialState","performStateChangeEffects","watch","prev","cleanup","entries","isEqual","compareFns","is","contextWatchers","add","performExitEffects","exit","setState","setEvent","stopStateListeners","stopChildren","stopActivities","stopDelayedEvents","stopContextWatchers","delayedEvents","stop","activityEvents","get","delete","state2","evt","to","contextSnapshot","child","children","send","has","parent","src","actor","setParent","set","onDone","removeChild","start","cleanups","stateNode","getStateNode","opts","actionMap","delayMap","delays","activityMap","determineTransition","isTargetless","reenter","internal","info","log","globalThis","setTimeout","clearTimeout","after","exits","JSON","stringify","determineDelay","__delay","getAfterActions","push","pickedActions","guardMeta","action","activity","name","addActivityCleanup","callbackfn","picked","delayOrFn","determineDelay2","delay2","setInterval","clearInterval","interval","current","currentState","_exit","exitActions","afterExitActions","createEveryActivities","unshift","entryActions","afterActions","getDelayedEventActions","doneListeners","performTransitionEffects","performEntryEffects","debug","msg","getState","self","bind","sendParent","sendChild","stopChild","spawn","stopActivity","getAction","getGuard","Symbol","toStringTag","getHydrationState","createMachine","isMachine","clsx","_len9","args","_key9","str","trim","join","CSS_REGEX","serialize","style","match","css","b","assign","mergeProps","result","_len10","_key10","props","startsWith"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/core/src/index.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/utilities/core/src/array.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/utilities/core/src/functions.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/utilities/core/src/guard.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/utilities/core/src/object.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/utilities/core/src/warning.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/core/src/deep-merge.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/core/src/utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/core/src/guard-utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/core/src/machine.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/core/src/create-proxy.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/core/src/delay-utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/core/src/transition-utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/qr-code/node_modules/@zag-js/core/src/merge-props.ts"],"sourcesContent":["export { proxy, ref, snapshot, subscribe, type Ref } from \"@zag-js/store\"\nexport { deepMerge } from \"./deep-merge\"\nexport { choose, guards } from \"./guard-utils\"\nexport * from \"./machine\"\nexport { mergeProps } from \"./merge-props\"\nexport type { ContextFrom, EventFrom, StateFrom } from \"./type-utils\"\nexport type { StateMachine } from \"./types\"\n","export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => v.filter((t) => t !== item)\n\nexport const removeAt = <T>(v: T[], i: number): T[] => v.filter((_, idx) => idx !== i)\n\nexport const uniq = <T>(v: T[]): T[] => Array.from(new Set(v))\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n","export type MaybeFunction<T> = T | (() => T)\n\nexport type Nullable<T> = T | null | undefined\n\nexport const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n\nexport const tryCatch = <R>(fn: () => R, fallback: () => R) => {\n  try {\n    return fn()\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch)\n    }\n    return fallback?.()\n  }\n}\n","export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\nexport const isNull = (v: any): v is null | undefined => v == null\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n","import { createSplitProps } from \"./split-props\"\n\nexport function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const filtered: Partial<T> = {}\n\n  for (const key of keys) {\n    const value = obj[key]\n    if (value !== undefined) {\n      filtered[key] = value\n    }\n  }\n\n  return filtered as any\n}\n\nexport function omit<T extends Record<string, any>>(obj: T, keys: string[]) {\n  return createSplitProps(keys)(obj)[1]\n}\n","export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n","import { compact, isObject } from \"@zag-js/utils\"\n\nexport function deepMerge<T extends Record<string, any>>(source: T, ...objects: T[]): T {\n  for (const obj of objects) {\n    const target = compact(obj)\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {} as any\n        }\n        deepMerge(source[key], obj[key])\n      } else {\n        source[key] = obj[key]\n      }\n    }\n  }\n  return source\n}\n","import { isArray, isObject, isString } from \"@zag-js/utils\"\nimport { klona } from \"klona/full\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\nexport function structuredClone<T>(v: T): T {\n  return klona(v)\n}\n\nexport function toEvent<T extends S.EventObject>(event: S.Event<T>): T {\n  const obj = isString(event) ? { type: event } : event\n  return obj as T\n}\n\nexport function toArray<T>(value: T | T[] | undefined): T[] {\n  if (!value) return []\n  return isArray(value) ? value.slice() : [value]\n}\n\nexport function isGuardHelper(value: any): value is { predicate: (guards: Dict) => any } {\n  return isObject(value) && value.predicate != null\n}\n","import { isFunction, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { isGuardHelper } from \"./utils\"\n\nconst Truthy = () => true\n\n/* -----------------------------------------------------------------------------\n * The following functions are used to determine a guard's truthiness\n * -----------------------------------------------------------------------------*/\n\nfunction exec<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guardMap: Dict,\n  ctx: TContext,\n  event: TEvent,\n  meta: S.GuardMeta<TContext, TState, TEvent>,\n) {\n  return (guard: S.Guard<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta)\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta)\n    }\n    return guard.predicate(guardMap)(ctx, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Guard helpers (for combining guards)\n * -----------------------------------------------------------------------------*/\n\nfunction or<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean),\n  }\n}\n\nfunction and<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean),\n  }\n}\n\nfunction not<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  condition: S.Guard<TContext, TState, TEvent>,\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n      return !exec(guardMap, ctx, event, meta)(condition)\n    },\n  }\n}\n\nfunction stateIn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...values: TState[\"value\"][]\n): S.GuardExpression<TContext, TState, TEvent> {\n  return (_ctx, _evt, meta) => meta.state.matches(...values)\n}\n\nexport const guards = { or, and, not, stateIn }\n\n/* -----------------------------------------------------------------------------\n * Action guard helper. Used to determie the action to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function choose<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  actions: Array<{ guard?: S.Guard<TContext, TState, TEvent>; actions: S.PureActions<TContext, TState, TEvent> }>,\n): S.ChooseHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      actions.find((def) => {\n        const guard = def.guard ?? Truthy\n        return exec(guardMap, ctx, event, meta)(guard)\n      })?.actions,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the guard to be used\n * -----------------------------------------------------------------------------*/\n\nexport function determineGuardFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guard: S.Guard<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  guard = guard ?? Truthy\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      const value = guardMap[guard]\n      return isFunction(value) ? value(context, event, meta) : value\n    }\n\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta)\n    }\n\n    return guard?.(context, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the actions to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function determineActionsFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  values: S.Actions<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta)\n    }\n    return values\n  }\n}\n","import { ref, snapshot, subscribe } from \"@zag-js/store\"\nimport {\n  cast,\n  clear,\n  compact,\n  hasProp,\n  invariant,\n  isArray,\n  isDev,\n  isObject,\n  isString,\n  noop,\n  runIfFn,\n  uuid,\n  warn,\n} from \"@zag-js/utils\"\nimport { createProxy } from \"./create-proxy\"\nimport { deepMerge } from \"./deep-merge\"\nimport { determineDelayFn } from \"./delay-utils\"\nimport { determineActionsFn, determineGuardFn } from \"./guard-utils\"\nimport { determineTransitionFn } from \"./transition-utils\"\nimport {\n  ActionTypes,\n  MachineStatus,\n  MachineType,\n  type Dict,\n  type StateMachine as S,\n  type VoidFunction,\n  type Writable,\n} from \"./types\"\nimport { structuredClone, toArray, toEvent } from \"./utils\"\n\nexport class Machine<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> {\n  public status: MachineStatus = MachineStatus.NotStarted\n  public readonly state: S.State<TContext, TState, TEvent>\n\n  public initialState: S.StateInfo<TContext, TState, TEvent> | undefined\n  public initialContext: TContext\n\n  public id: string\n\n  public type: MachineType = MachineType.Machine\n\n  // Cleanup function map (per state)\n  private activityEvents = new Map<string, Map<string, VoidFunction>>()\n  private delayedEvents = new Map<string, VoidFunction[]>()\n\n  // state update listeners the user can opt-in for\n  private stateListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private doneListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextWatchers = new Set<VoidFunction>()\n\n  // Cleanup functions (for `subscribe`)\n  private removeStateListener: VoidFunction = noop\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: AnyMachine\n  private children = new Map<string, AnyMachine>()\n\n  // A map of guard, action, delay implementations\n  private guardMap: S.GuardMap<TContext, TState, TEvent>\n  private actionMap: S.ActionMap<TContext, TState, TEvent>\n  private delayMap: S.DelayMap<TContext, TEvent>\n  private activityMap: S.ActivityMap<TContext, TState, TEvent>\n  private sync: boolean\n  public options: S.MachineOptions<TContext, TState, TEvent>\n  public config: S.MachineConfig<TContext, TState, TEvent>\n\n  // Let's get started!\n  constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent>) {\n    // clone the config and options\n    this.config = structuredClone(config)\n    this.options = structuredClone(options ?? {})\n\n    this.id = this.config.id ?? `machine-${uuid()}`\n\n    // maps\n    this.guardMap = this.options?.guards ?? {}\n    this.actionMap = this.options?.actions ?? {}\n    this.delayMap = this.options?.delays ?? {}\n    this.activityMap = this.options?.activities ?? {}\n    this.sync = this.options?.sync ?? false\n\n    // create mutatable state\n    this.state = createProxy(this.config)\n\n    this.initialContext = snapshot(this.state.context)\n  }\n\n  // immutable state value\n  private get stateSnapshot(): S.State<TContext, TState, TEvent> {\n    return cast(snapshot(this.state))\n  }\n\n  public getState(): S.State<TContext, TState, TEvent> {\n    return this.stateSnapshot\n  }\n\n  // immutable context value\n  public get contextSnapshot(): TContext {\n    return this.stateSnapshot.context\n  }\n\n  public _created = () => {\n    // created actions\n    const event = toEvent<TEvent>(ActionTypes.Created)\n    this.executeActions(this.config?.created, event)\n  }\n\n  // Starts the interpreted machine.\n  public start = (init?: S.StateInit<TContext, TState>) => {\n    // reset state back to empty (for SSR, we had to set state.value to initial value)\n    this.state.value = \"\"\n    this.state.tags = []\n\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) {\n      return this\n    }\n\n    this.status = MachineStatus.Running\n\n    // subscribe to state changes\n    this.removeStateListener = subscribe(\n      this.state,\n      () => {\n        this.stateListeners.forEach((listener) => {\n          listener(this.stateSnapshot)\n        })\n      },\n      this.sync,\n    )\n\n    this.setupContextWatchers()\n\n    // execute initial actions and activities\n    this.executeActivities(toEvent<TEvent>(ActionTypes.Start), toArray(this.config.activities), ActionTypes.Start)\n    this.executeActions(this.config.entry, toEvent<TEvent>(ActionTypes.Start))\n\n    // start transition\n    const event = toEvent<TEvent>(ActionTypes.Init)\n\n    const target = isObject(init) ? init.value : init\n    const context = isObject(init) ? init.context : undefined\n\n    if (context) {\n      this.setContext(context as Partial<TContext>)\n    }\n\n    // start transition definition\n    const transition = {\n      target: target ?? this.config.initial,\n    }\n\n    const next = this.getNextStateInfo(transition, event)\n    this.initialState = next\n\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return this\n  }\n\n  private setupContextWatchers = () => {\n    const { watch } = this.config\n    if (!watch) return\n\n    let prev = snapshot(this.state.context)\n\n    const cleanup = subscribe(this.state.context, () => {\n      const next = snapshot(this.state.context)\n\n      for (const [key, fn] of Object.entries(watch)) {\n        const isEqual = this.options.compareFns?.[key] ?? Object.is\n        if (isEqual(prev[key], next[key])) continue\n        this.executeActions(fn, this.state.event as TEvent)\n      }\n\n      prev = next\n    })\n\n    this.contextWatchers.add(cleanup)\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    // exit current state\n    this.performExitEffects(this.state.value!, toEvent<TEvent>(ActionTypes.Stop))\n\n    // execute root stop or exit actions\n    this.executeActions(this.config.exit, toEvent<TEvent>(ActionTypes.Stop))\n\n    this.setState(\"\")\n    this.setEvent(ActionTypes.Stop)\n\n    // cleanups\n    this.stopStateListeners()\n    this.stopChildren()\n    this.stopActivities()\n    this.stopDelayedEvents()\n    this.stopContextWatchers()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopStateListeners = () => {\n    this.removeStateListener()\n    this.stateListeners.clear()\n  }\n\n  private stopContextWatchers = () => {\n    this.contextWatchers.forEach((fn) => fn())\n    this.contextWatchers.clear()\n  }\n\n  private stopDelayedEvents = () => {\n    this.delayedEvents.forEach((state) => {\n      state.forEach((stop) => stop())\n    })\n    this.delayedEvents.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (state?: TState[\"value\"]) => {\n    // stop activities for a state\n    if (state) {\n      this.activityEvents.get(state)?.forEach((stop) => stop())\n      this.activityEvents.get(state)?.clear()\n      this.activityEvents.delete(state)\n    } else {\n      // stop every running activity\n      this.activityEvents.forEach((state) => {\n        state.forEach((stop) => stop())\n        state.clear()\n      })\n      this.activityEvents.clear()\n    }\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  public sendChild = (evt: S.Event<S.AnyEventObject>, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = runIfFn(to, this.contextSnapshot)\n    const child = this.children.get(id)\n    if (!child) {\n      invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`)\n    }\n    child!.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  public stopChild = (id: string) => {\n    if (!this.children.has(id)) {\n      invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`)\n    }\n    this.children.get(id)!.stop()\n    this.children.delete(id)\n  }\n\n  public removeChild = (id: string) => {\n    this.children.delete(id)\n  }\n\n  // Stop and delete spawned actors\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  public spawn = <TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(\n    src: MachineSrc<TContext, TState, TEvent>,\n    id?: string,\n  ) => {\n    const actor = runIfFn(src)\n    if (id) actor.id = id\n    actor.type = MachineType.Actor\n    actor.setParent(this)\n    this.children.set(actor.id, cast(actor))\n\n    actor\n      .onDone(() => {\n        this.removeChild(actor.id)\n      })\n      .start()\n\n    return cast<typeof actor>(ref(actor))\n  }\n\n  private stopActivity = (key: string) => {\n    if (!this.state.value) return\n    const cleanups = this.activityEvents.get(this.state.value)\n    cleanups?.get(key)?.() // cleanup\n    cleanups?.delete(key) // remove from map\n  }\n\n  private addActivityCleanup = (state: TState[\"value\"] | null, key: string, cleanup: VoidFunction) => {\n    if (!state) return\n    if (!this.activityEvents.has(state)) {\n      this.activityEvents.set(state, new Map([[key, cleanup]]))\n    } else {\n      this.activityEvents.get(state)?.set(key, cleanup)\n    }\n  }\n\n  private setState = (target: TState[\"value\"] | null) => {\n    this.state.previousValue = this.state.value\n    this.state.value = target\n\n    const stateNode = this.getStateNode(target)\n\n    if (target == null) {\n      // remove all tags\n      clear(this.state.tags)\n    } else {\n      this.state.tags = toArray(stateNode?.tags)\n    }\n  }\n\n  /**\n   * To used within side effects for React or Vue to update context\n   */\n  public setContext = (context: Partial<Writable<TContext>> | undefined) => {\n    if (!context) return\n    deepMerge(this.state.context, compact(context))\n  }\n\n  public setOptions = (options: Partial<S.MachineOptions<TContext, TState, TEvent>>) => {\n    const opts = compact(options)\n    this.actionMap = { ...this.actionMap, ...opts.actions }\n    this.delayMap = { ...this.delayMap, ...opts.delays }\n    this.activityMap = { ...this.activityMap, ...opts.activities }\n    this.guardMap = { ...this.guardMap, ...opts.guards }\n  }\n\n  private getStateNode = (state: TState[\"value\"] | null) => {\n    if (!state) return\n    return this.config.states?.[state]\n  }\n\n  private getNextStateInfo = (\n    transitions: S.Transitions<TContext, TState, TEvent>,\n    event: TEvent,\n  ): S.StateInfo<TContext, TState, TEvent> => {\n    // pick transition\n    const transition = this.determineTransition(transitions, event)\n\n    const isTargetless = !transition?.target\n    const target = transition?.target ?? this.state.value\n    const changed = this.state.value !== target\n\n    const stateNode = this.getStateNode(target)\n    const reenter = !isTargetless && !changed && !transition?.internal\n\n    const info = {\n      reenter,\n      transition,\n      stateNode,\n      target: target!,\n      changed,\n    }\n\n    this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target)\n\n    return info\n  }\n\n  private getAfterActions = (transition: S.Transitions<TContext, TState, TEvent>, delay?: number) => {\n    let id: ReturnType<typeof globalThis.setTimeout>\n\n    return {\n      entry: () => {\n        id = globalThis.setTimeout(() => {\n          const next = this.getNextStateInfo(transition, this.state.event)\n          this.performStateChangeEffects(this.state.value!, next, this.state.event)\n        }, delay)\n      },\n      exit: () => {\n        globalThis.clearTimeout(id)\n      },\n    }\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the `after` defintion into `entry` and `exit`\n   *  functions and append them to the state's `entry` and `exit` actions\n   */\n  private getDelayedEventActions = (state: TState[\"value\"]) => {\n    const stateNode = this.getStateNode(state)\n    const event = this.state.event\n\n    if (!stateNode || !stateNode.after) return\n\n    const entries: VoidFunction[] = []\n    const exits: VoidFunction[] = []\n\n    if (isArray(stateNode.after)) {\n      //\n      const transition = this.determineTransition(stateNode.after, event)\n\n      if (!transition) return\n\n      if (!hasProp(transition, \"delay\")) {\n        throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`)\n      }\n\n      const determineDelay = determineDelayFn((transition as any).delay, this.delayMap)\n      const __delay = determineDelay(this.contextSnapshot, event)\n\n      const actions = this.getAfterActions(transition, __delay)\n\n      entries.push(actions.entry)\n      exits.push(actions.exit)\n\n      return { entries, exits }\n    }\n\n    if (isObject(stateNode.after)) {\n      //\n      for (const delay in stateNode.after) {\n        const transition = stateNode.after[delay]\n\n        const determineDelay = determineDelayFn(delay, this.delayMap)\n        const __delay = determineDelay(this.contextSnapshot, event)\n\n        const actions = this.getAfterActions(transition, __delay)\n\n        entries.push(actions.entry)\n        exits.push(actions.exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  private get self(): S.Self<TContext, TState, TEvent> {\n    const self = this\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this) as any,\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot\n      },\n      get initialContext() {\n        return self.initialContext\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\"\n      },\n    }\n  }\n\n  private get meta(): S.Meta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key],\n    }\n  }\n\n  private get guardMeta(): S.GuardMeta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n    }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actions`) or actual functions.\n   */\n  private executeActions = (actions: S.Actions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    for (const action of toArray(pickedActions)) {\n      const fn = isString(action) ? this.actionMap?.[action] : action\n      warn(\n        isString(action) && !fn,\n        `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``,\n      )\n      fn?.(this.state.context, event, this.meta)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: Array<S.Activity<TContext, TState, TEvent>>,\n    state?: TState[\"value\"],\n  ) => {\n    for (const activity of activities) {\n      const fn = isString(activity) ? this.activityMap?.[activity] : activity\n\n      if (!fn) {\n        warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``)\n        continue\n      }\n\n      const cleanup = fn(this.state.context, event, this.meta)\n\n      if (cleanup) {\n        const key = isString(activity) ? activity : activity.name || uuid()\n        this.addActivityCleanup(state ?? this.state.value, key, cleanup)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to transition. `every` can be:\n   * - An array of possible actions to run (we need to pick the first match based on guard)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"] | undefined,\n    callbackfn: (activity: S.Activity<TContext, TState, TEvent>) => void,\n  ) => {\n    if (!every) return\n\n    // every: [{ interval: 2000, actions: [...], guard: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], guard: ... }\n      const picked = toArray(every).find((transition) => {\n        //\n        const delayOrFn = transition.delay\n        const determineDelay = determineDelayFn(delayOrFn, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        const determineGuard = determineGuardFn(transition.guard, this.guardMap)\n        const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta)\n\n        return guard ?? delay != null\n      })\n\n      if (!picked) return\n\n      const determineDelay = determineDelayFn(picked.delay, this.delayMap)\n      const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n      const activity = () => {\n        const id = globalThis.setInterval(() => {\n          this.executeActions(picked.actions, this.state.event)\n        }, delay)\n        return () => {\n          globalThis.clearInterval(id)\n        }\n      }\n      callbackfn(activity)\n      //\n    } else {\n      // every = { 1000: [fn, fn] }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const determineDelay = determineDelayFn(interval, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        // create the activity to run for each `every` reaction\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(actions, this.state.event)\n          }, delay)\n          return () => {\n            globalThis.clearInterval(id)\n          }\n        }\n        callbackfn(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent | TEvent[\"type\"]) => {\n    this.state.previousEvent = this.state.event\n    this.state.event = ref(toEvent(event))\n  }\n\n  private performExitEffects = (current: TState[\"value\"] | undefined, event: TEvent) => {\n    const currentState = this.state.value!\n\n    // don't clean up root state, it'll get cleaned up on stop()\n    if (currentState === \"\") return\n\n    const stateNode = current ? this.getStateNode(current) : undefined\n\n    // cleanup activities for current state\n    this.stopActivities(currentState)\n\n    // get explicit exit and implicit \"after.exit\" actions for current state\n    const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    const exitActions = toArray(_exit)\n\n    const afterExitActions = this.delayedEvents.get(currentState)\n\n    if (afterExitActions) {\n      exitActions.push(...afterExitActions)\n    }\n\n    // call all exit actions for current state\n    this.executeActions(exitActions, event)\n  }\n\n  private performEntryEffects = (next: TState[\"value\"], event: TEvent) => {\n    const stateNode = this.getStateNode(next)\n\n    // execute activities for next state\n    const activities = toArray(stateNode?.activities)\n\n    // if `every` is defined, create an activity and append to activities\n    this.createEveryActivities(stateNode?.every, (activity) => {\n      activities.unshift(activity)\n    })\n\n    if (activities.length > 0) {\n      this.executeActivities(event, activities)\n    }\n\n    // get all entry actions\n    const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n      this.contextSnapshot,\n      event,\n      this.guardMeta,\n    )\n    const entryActions = toArray(pickedActions)\n    const afterActions = this.getDelayedEventActions(next)\n\n    if (stateNode?.after && afterActions) {\n      this.delayedEvents.set(next, afterActions?.exits)\n      entryActions.push(...afterActions.entries)\n    }\n\n    // execute entry actions for next state\n    this.executeActions(entryActions, event)\n\n    if (stateNode?.type === \"final\") {\n      this.state.done = true\n      this.doneListeners.forEach((listener) => {\n        listener(this.stateSnapshot)\n      })\n      this.stop()\n    }\n  }\n\n  private performTransitionEffects = (\n    transitions: S.Transitions<TContext, TState, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    // execute transition actions\n    const transition = this.determineTransition(transitions, event)\n    this.executeActions(transition?.actions, event)\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performStateChangeEffects = (\n    current: TState[\"value\"] | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    // update event\n    this.setEvent(event)\n\n    const changed = next.changed || next.reenter\n\n    if (changed) {\n      this.performExitEffects(current, event)\n    }\n\n    // execute transition actions\n    this.performTransitionEffects(next.transition, event)\n\n    // go to next state\n    this.setState(next.target)\n\n    if (changed) {\n      this.performEntryEffects(next.target, event)\n    }\n  }\n\n  private determineTransition = (transition: S.Transitions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const fn = determineTransitionFn(transition, this.guardMap)\n    return fn?.(this.contextSnapshot, event, this.guardMeta)\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  public sendParent = (evt: S.Event<S.AnyEventObject>) => {\n    if (!this.parent) {\n      invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\")\n    }\n    const event = toEvent<S.AnyEventObject>(evt)\n    this.parent?.send(event)\n  }\n\n  private log = (...args: any[]) => {\n    if (isDev() && this.options.debug) {\n      console.log(...args)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  public send = (evt: S.Event<TEvent>) => {\n    const event = toEvent<TEvent>(evt)\n    this.transition(this.state.value, event)\n  }\n\n  public transition = (state: TState[\"value\"] | S.StateInfo<TContext, TState, TEvent> | null, evt: S.Event<TEvent>) => {\n    const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode\n\n    const event = toEvent(evt)\n\n    if (!stateNode && !this.config.on) {\n      const msg =\n        this.status === MachineStatus.Stopped\n          ? \"[@zag-js/core > transition] Cannot transition a stopped machine\"\n          : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`\n      warn(msg)\n      return\n    }\n\n    const transitions: S.Transitions<TContext, TState, TEvent> =\n      // @ts-expect-error - Fix this\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const next = this.getNextStateInfo(transitions, event)\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return next.stateNode\n  }\n\n  subscribe = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n\n    return () => {\n      this.stateListeners.delete(listener)\n    }\n  }\n\n  public onDone = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.doneListeners.add(listener)\n    return this\n  }\n\n  public onTransition = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n    return this\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Machine\"\n  }\n\n  public getHydrationState(): S.StateInit<TContext, TState> {\n    const state = this.getState()\n    return {\n      value: state.value,\n      tags: state.tags,\n    }\n  }\n}\n\nexport type MachineSrc<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> = Machine<TContext, TState, TEvent> | (() => Machine<TContext, TState, TEvent>)\n\nexport type AnyMachine = Machine<Dict, S.StateSchema, S.AnyEventObject>\n\nexport const createMachine = <\n  TContext extends Dict,\n  TState extends S.StateSchema = S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n  options?: S.MachineOptions<TContext, TState, TEvent>,\n) => new Machine(config, options)\n\nexport const isMachine = (value: any): value is AnyMachine => {\n  return value instanceof Machine || value?.type === MachineType.Machine\n}\n","import { proxy, proxyWithComputed } from \"@zag-js/store\"\nimport { cast } from \"@zag-js/utils\"\nimport { ActionTypes, type Dict, type StateMachine as S } from \"./types\"\n\nexport function createProxy<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n) {\n  const computedContext: Dict = config.computed ?? cast<S.TComputedContext<TContext>>({})\n  const initialContext = config.context ?? cast<TContext>({})\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : []\n\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast<Dict>({}),\n    previousEvent: cast<Dict>({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: (initialTags ?? []) as Array<TState[\"tags\"]>,\n    hasTag(tag: TState[\"tags\"]): boolean {\n      return this.tags.includes(tag)\n    },\n    matches(...value: string[]): boolean {\n      return value.includes(this.value)\n    },\n    can(event: string): boolean {\n      return cast<any>(this).nextEvents.includes(event)\n    },\n    get nextEvents() {\n      const stateEvents = (config.states as Dict)?.[this.value]?.[\"on\"] ?? {}\n      const globalEvents = config?.on ?? {}\n      return Object.keys({ ...stateEvents, ...globalEvents })\n    },\n    get changed() {\n      if (this.event.value === ActionTypes.Init || !this.previousValue) return false\n      return this.value !== this.previousValue\n    },\n  })\n\n  return cast<S.State<TContext, TState, TEvent>>(state)\n}\n","import { invariant, isFunction, isNumber, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\n/**\n * Delay can be specified as:\n * - a string (reference to `options.delays`)\n * - a number (in ms)\n * - a function that returns a number (in ms)\n *\n * Let's resolve this to a number\n */\nexport function determineDelayFn<TContext extends Dict, TEvent extends S.EventObject>(\n  delay: S.Delay<TContext, TEvent> | undefined,\n  delaysMap: S.DelayMap<TContext, TEvent> | undefined,\n) {\n  return (context: TContext, event: TEvent) => {\n    if (isNumber(delay)) return delay\n\n    if (isFunction(delay)) {\n      return delay(context, event)\n    }\n\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay)\n\n      if (!Number.isNaN(value)) {\n        return value\n      }\n\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay]\n\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``,\n        )\n\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn\n      }\n    }\n  }\n}\n","import { isString } from \"@zag-js/utils\"\nimport { determineGuardFn } from \"./guard-utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { toArray } from \"./utils\"\n\n/**\n * A transition is an object that describes the next state, or/and actions\n * that should run when an event is sent.\n *\n * Transitions can be specified as:\n * - A single string: \"spinning\"\n * - An object with `target`, `actions`, or `guard`: { target: \"spinning\", actions: [...], guard: isValid }\n * - An array of possible transitions. In this case, we'll pick the first matching transition\n * depending on the `guard` specified\n */\n\nexport function toTarget<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  target: S.Transition<TContext, TState, TEvent>,\n): S.TransitionDefinition<TContext, TState, TEvent> {\n  return isString(target) ? { target } : target\n}\n\nexport function determineTransitionFn<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject,\n>(transitions: S.Transitions<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    return toArray(transitions)\n      .map(toTarget)\n      .find((transition) => {\n        // get condition function\n        const determineGuard = determineGuardFn(transition.guard, guardMap)\n        const guard = determineGuard(context, event, meta)\n        return guard ?? transition.target ?? transition.actions\n      })\n  }\n}\n","import { callAll, isString } from \"@zag-js/utils\"\n\ninterface Props {\n  [key: string]: any\n}\n\nconst clsx = (...args: (string | undefined)[]) =>\n  args\n    .map((str) => str?.trim?.())\n    .filter(Boolean)\n    .join(\" \")\n\nconst CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g\n\nconst serialize = (style: string): Record<string, string> => {\n  const res: Record<string, string> = {}\n  let match: RegExpExecArray | null\n  while ((match = CSS_REGEX.exec(style))) {\n    res[match[1]!] = match[2]!\n  }\n  return res\n}\n\nconst css = (\n  a: Record<string, string> | string | undefined,\n  b: Record<string, string> | string | undefined,\n): Record<string, string> | string => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`\n    a = serialize(a)\n  } else if (isString(b)) {\n    b = serialize(b)\n  }\n  return Object.assign({}, a ?? {}, b ?? {})\n}\n\ntype TupleTypes<T extends any[]> = T[number]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never\n\nexport function mergeProps<T extends Props>(...args: T[]): UnionToIntersection<TupleTypes<T[]>> {\n  let result: Props = {}\n\n  for (let props of args) {\n    for (let key in result) {\n      if (key.startsWith(\"on\") && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key])\n        continue\n      }\n\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key])\n        continue\n      }\n\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key])\n        continue\n      }\n\n      result[key] = props[key] !== undefined ? props[key] : result[key]\n    }\n\n    // Add props from b that are not in a\n    for (let key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as any\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}